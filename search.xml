<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CocosCreator 引擎资源加载与释放原理简析]]></title>
    <url>%2F2019%2F03%2F15%2FCocosCreator%20%E5%BC%95%E6%93%8E%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%87%8A%E6%94%BE%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文主要内容如下： 资源加载与释放部分代码所在 调试、修改引擎源码的方法 资源加载与释放原理简析 如要了解 CocosCreator 引擎资源加载与释放的原理，调试、修改引擎代码有助于对其原理进行理解。因此文中会先介绍 CocosCreator 引擎各部分及其文件夹，然后介绍调试、修改引擎源码的方法，最后对其原理进行分析。 如果你对阅读、调试修改源码不感兴趣，可直接跳转到第三部分阅读。如果你对此主题不感兴趣，可直接关闭网页。 本文基于 CocosCreator 1.10.2，另外 2.0.8 版本关于资源加载释放部分改动不大，也可适用 前言Cocos Creator 的引擎部分包括 JavaScript、Cocos2d-x-lite 和 adapter 三个部分，各部分对应源码在（Mac 版）： JavaScript：CocosCreator.app/Resource/engine（JS 引擎） Cocos2d-x-lite：CocosCreator.app/Resource/cocos2d-x（Cococ2d-x 引擎） adapter：CocosCreator.app/Resource/builtin/ 其中 engine 文件夹下代码部分包含了引擎的 JS 层逻辑，而引擎的资源加载与释放部分代码就处于此文件夹中，路径为 cocos2d/core/load-pipeline/，主要涉及 pipeline.js、loading-items.js、CCLoader.js、loader.js、uuid-loader.js 等文件。 另外，需要了解的是 CocosCreator 引擎中资源是有依赖关系的，比如 SpriteAtlas 资源的加载会依赖于多个 SpriteFrame 资源的加载，而 SpriteFrame 资源依赖于 Texture2D 资源。 下边对调试、修改引擎代码做简单介绍。 调试、修改引擎代码 找到 CocosCreator 的 JavaScript 引擎所在目录 CocosCreator.app/Resource/engine，将该文件夹复制到其他地方，我们将对复制后的代码进行调试和修改。然后在 CocosCreator 的项目设置中修改 JavaScript 引擎路径为复制后的路径。如果要调试 Cocos2d-x 部分，修改对应文件夹即可。如下图： 运行以下命令安装编译依赖 123456# 在命令行中进入引擎路径cd [engine_path]/engine# 安装 gulp 构建工具npm install -g gulp# 安装依赖的模块npm install 现在可以打开 engine 文件夹，对 JS 引擎部分进行修改。修改后，在该文件夹下运行 gulp build 命令即可编译修改的部分，然后刷新 CocosCreator 预览的网页即可 至于调试其源码，可以直接在 Chrome 开发者工具中 Cmd + o （Mac 快捷键）呼出搜索框，输入并打开你需要调试的文件，然后即可打断点进行调试 CocosCreator 引擎资源加载与释放简析引擎资源加载与释放源码路径为 engine/cocos2d/core/load-pipeline/，主要关注 pipeline.js、loading-items.js、CCLoader.js、loader.js、uuid-loader.js 这几个文件。 其中资源加载涉及 CCLoader、pipeline、loading-items、loader、uuid-loader 等多个类，而资源释放则主要是 CCLoader 中的 release 方法。 资源加载概括来讲，CCLoader 是供上层直接使用加载、释放资源的类，整合、封装了 pipeline、loading-items、loader 等类；pipeline 包含多个 pipe，这里的 pipe 是指实现了加载资源的单位（如 loader），pipeline 对资源的处理最终是调用 pipe.handle 实现的，pipeline 自身实现的是资源缓存和让资源依次流过管道，即每个资源依次经过每个 pipe 的处理；loading-items 配合 pipeline，实现了加载状态维护、依赖资源入队等内容；asset-loader、downloader、loader 则实现了资源加载具体功能，不同的加载器负责不同资源的加载。 简化来看，一次资源的加载流程底层的调用函数如下： cc.loader.loadRes() CCLoader.load() loading-items.append pipeline.flowIn pipeline.flow pipe.handle（pipe 对应于 asset-loader、downloader、loader） 加载完成，进行回调 加载流程中其实还有一种情况需要注意：loader 其实会根据资源类型将加载任务分发给不同的类，如 uuid 类型会交给 uuid-loader。uuid-loader 加载时会加载该资源的依赖资源，其过程为： uuid-loader.loadUuid uuid-loader.loadDepends pipeline.flowInDeps loading-items.append 后续流程和正常流程一致 以下会根据加载流程分析一下是如何加载资源的。 CCLoaderCCLoader 继承自 pipeline，是用户可以直接调用来加载、释放资源的类，它对 pipeline、loading-items、loader 进行了整合封装，并提供了 load、loadRes、loadResDir、release、releaseRes 等方法供用户使用。资源加载相关的便是 load、loadRes 等方法，而所有方法最终是调用 load 方法来进行资源加载的。load 方法如下： 123456789101112131415161718192021222324proto.load = function(resources, progressCallback, completeCallback) &#123; // 省略部分代码 _sharedResources.length = 0; for (var i = 0; i &lt; resources.length; ++i) &#123; var resource = resources[i]; // 省略部分代码 var res = getResWithUrl(resource); if (!res.url &amp;&amp; !res.uuid) continue; var item = this._cache[res.url]; _sharedResources.push(item || res); &#125; var queue = LoadingItems.create(this, progressCallback, function (errors, items) &#123; callInNextTick(function () &#123; // 省略部分代码 &#125;); &#125;); LoadingItems.initQueueDeps(queue); queue.append(_sharedResources); _sharedResources.length = 0; 可以看到 load 方法中，所做的就是创建一个 LoadingItem，然后对其进行初始化，之后调用其 append 方法。这里 LoadingItem 简单来看就是对待加载资源的一层封装。下边介绍 loading-items。 loading-itemsloading-items 主要是完善了每个资源对象的属性，包括资源内容、url 地址等，同时维护每个资源的加载状态、依赖关系等。以下是 append 方法代码。 1234567891011121314151617181920212223242526272829303132333435proto.append = function (urlList, owner) &#123; // 省略代码 this._appending = true; var accepted = [], i, url, item; for (i = 0; i &lt; urlList.length; ++i) &#123; // 省略代码，主要是对每个资源的依赖关系、循环依赖、是否完成等进行处理 // Queue new items if (isIdValid(url)) &#123; item = createItem(url, this._id); var key = item.id; // No duplicated url if (!this.map[key]) &#123; this.map[key] = item; this.totalCount++; // Register item deps for circle reference check owner &amp;&amp; owner.deps.push(item); LoadingItems.registerQueueDep(owner || this._id, key); accepted.push(item); // console.log('+++++ Appended ' + item.id); &#125; &#125; &#125; this._appending = false; // Manually complete if (this.completedCount === this.totalCount) &#123; this.allComplete(); &#125; else &#123; this._pipeline.flowIn(accepted); &#125; return accepted;&#125;; 从代码可以看出，append 所做的是：先对资源列表 urlList 里每一个元素做字段完善（create）、依赖处理（registerQueueDep），然后调用 pipeline.flowIn 将所有未加载完成的资源放入 pipeline 之中。下边介绍 pipeline。 pipelinepipeline 包含多个 pipe，pipe 存储在 _pipes 数组中，而且数组中的 nextPipe 赋值给了 lastPipe.next，以此将 pipe 链接成单向链表结构。这里的 pipe 是指实现了加载资源的单位（如 loader），pipeline 对资源的处理最终是调用 pipe.handle 实现的，pipeline 自身实现的是资源缓存和让资源依次流过管道，即每个资源依次经过每个 pipe 的处理。在 CCLoader 初始化 pipeline 时，为它添加了 AssetLoader、Downloader、Loader 三个 pipe，每个资源都会依次经过这三个 pipe 的处理。pipeline 中的 _cache 数组是对每个资源的缓存。 以下是其 flowIn 方法： 12345678910111213141516171819proto.flowIn = function (items) &#123; var i, pipe = this._pipes[0], item; if (pipe) &#123; // Cache all items first, in case synchronous loading flow same item repeatly for (i = 0; i &lt; items.length; i++) &#123; item = items[i]; this._cache[item.id] = item; &#125; for (i = 0; i &lt; items.length; i++) &#123; item = items[i]; flow(pipe, item); &#125; &#125; else &#123; for (i = 0; i &lt; items.length; i++) &#123; this.flowOut(items[i]); &#125; &#125;&#125;; flowIn 方法所做其实就是：先将每个资源 item 缓存到 _cache 中，然后对每个 item 调用 flow 方法。这里要注意的是 flow 的 pipe 参数为 _pipes[0]，即先将资源交给 pipeline 的第一个 pipe。以下是 flow 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function flow (pipe, item) &#123; var pipeId = pipe.id; var itemState = item.states[pipeId]; var next = pipe.next; var pipeline = pipe.pipeline; if (item.error || itemState === ItemState.WORKING || itemState === ItemState.ERROR) &#123; return; &#125; else if (itemState === ItemState.COMPLETE) &#123; if (next) &#123; flow(next, item); &#125; else &#123; pipeline.flowOut(item); &#125; &#125; else &#123; item.states[pipeId] = ItemState.WORKING; // Pass async callback in case it's a async call var result = pipe.handle(item, function (err, result) &#123; // 省略代码 &#125;); // If result exists (not undefined, null is ok), then we go with sync call flow if (result instanceof Error) &#123; item.error = result; item.states[pipeId] = ItemState.ERROR; pipeline.flowOut(item); &#125; else if (result !== undefined) &#123; // Result can be null, then it means no result for this pipe if (result !== null) &#123; item.content = result; &#125; item.states[pipeId] = ItemState.COMPLETE; if (next) &#123; flow(next, item); &#125; else &#123; pipeline.flowOut(item); &#125; &#125; &#125;&#125; flow 方法中对资源的处理分为三部分： 如果资源状态为 ERROR，则直接返回 如果资源状态为 COMPLETE 已完成，如果后续还有 pipe 就将其交给下一个 pipe 处理 如果资源状态为空，说明此资源从未进行加载，则调用 pipe.handle 方法对其进行加载。加载完成后，先将加载结果交给 item，即item.content = result，然后会对其加载状态 states 进行修改，最后如果后续还有 pipe 就将其交给后续 pipe 处理。 接下来再来看一下 pipe.handle 方法。从以下代码可以看出， CCLoader 初始化时，提供了三个 pipe：asset-loader、downloader、loader。实际上 pipe.handle 调用的其实是 assetLoader、downloader、loader 的 handle 方法，下边以 loader 为例进行介绍。 123456789101112function CCLoader () &#123; var assetLoader = new AssetLoader(); var downloader = new Downloader(); var loader = new Loader(); Pipeline.call(this, [ assetLoader, downloader, loader ]); // 省略代码&#125; loaderloader 是 CCLoader 中添加到 pipeline 的 pipe 之一，其作用就是加载资源，pipeline 会直接调用其 handle 方法来加载资源。类似的类有 asset-loader、downloader。而 loader 相对特殊是它其中又会根据资源类型不同，调用不同的类去实现加载功能。比如 uuid 类型会调用 uuid-loader 来加载。这里提到的 uuid-loader 在加载资源的时候，会去判断资源是否有依赖资源，如果有会将依赖资源添加到 pipeline 中，进而对依赖资源进行加载。 loader 的部分代码如下： 12345678910111213141516171819202122var defaultMap = &#123; // Images 'png' : loadImage, 'jpg' : loadImage, 'bmp' : loadImage, // 省略代码 'uuid' : loadUuid, 'prefab' : loadUuid, 'fire' : loadUuid, 'scene' : loadUuid, 'default' : loadNothing&#125;;// 省略代码Loader.prototype.handle = function (item, callback) &#123; var loadFunc = this.extMap[item.type] || this.extMap['default']; return loadFunc.call(this, item, callback);&#125;; 可以看出 loader 会根据资源类型不同，进而调用对应的类去实现加载功能。如 uuid 类型资源，调用的是 uuid-loader 的 loadUuid 方法。而至于 loadUuid 方法中，则做了 deserialize 资源、解析处理依赖资源等。 资源释放CCLoader 对于资源释放提供了 release、releaseRes、releaseAsset、releaseResDir、releaseAll 方法，但实际上所有方法最终是调用 release 方法来实现资源释放的，在 release 调用之前所做的就是获取资源对应的 uuid，然后调用 release 方法。以下是 release 方法： 1234567891011121314151617181920212223242526proto.release = function (asset) &#123; if (Array.isArray(asset)) &#123; for (let i = 0; i &lt; asset.length; i++) &#123; var key = asset[i]; this.release(key); &#125; &#125; else if (asset) &#123; var id = this._getReferenceKey(asset); var item = this.getItem(id); if (item) &#123; var removed = this.removeItem(id); asset = item.content; if (cc.Class.isInstanceOf(asset, cc.Asset)) &#123; if (asset.nativeUrl) &#123; this.release(asset.nativeUrl); // uncache loading item of native asset &#125; asset.destroy(); &#125; if (CC_DEBUG &amp;&amp; removed) &#123; this._releasedAssetChecker_DEBUG.setReleased(item, id); &#125; &#125; &#125;&#125;; 从代码中可以看到，release 分为两部分： 如果资源是数组，则对数组中的每个元素调用 release 第二部分是释放资源的关键，所做的工作可以简化如下： 获取资源在 pipeline._cache 中的缓存 item，并在 _cache 中移除该 item 拿到资源的实际内容，即 item.content，这也是 loader 加载出来的资源结果。如果 content 是 Asset 类型，则调用其 destroy 方法进行释放，同时释放其依赖的 nativeUrl 资源 如果是 debug 模式，则会在 released-asset-checker 中标记该资源为已释放 注： 这里的 released-asset-checker 是一个辅助类，其中一个作用就是检测已释放资源是否仍被其他资源引用 release 方法其实仍存在缺陷，缺陷之一是无法释放 SpriteAtlas 所依赖的 SpriteFrame 资源，在释放后 SpriteFrame 资源仍存在与 pipeline._cache 中。这导致释放后再次加载同一个 SpriteAtlas 资源的加载不完整问题，该问题的表现是第二次加载 SpriteAtlas 后播放帧动画黑块现象。原因是：加载到 SpriteAtlas 依赖的 SpriteFrame 资源部分时，根据 pipeline.flow 方法代码会发现由于此时 SpriteFrame.states = { “AssetLoader”: 2, “Downloader”: 2, “loader”: 2}，这里 2 代表加载状态 COMPLETE，就是说该资源在所有 pipe 的状态均是已加载完成，资源直接通过了三个管道，最后执行 flowOut 方法，没有继续加载 SpriteFrame 所依赖的 Texture2D 资源，导致显示黑块。 参考文章 引擎定制工作流程 CocosCreator API 文档 本文图片使用 Alfred Workflow：SmartPic 一键上传获取链接，点击查看 SmartPic 版权声明本文首发于个人博客：khanzhang.cn同步发于简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 开发知识概要]]></title>
    <url>%2F2019%2F03%2F09%2FAndroid%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[Android简介Android一词最早出现在法国作家维里耶德利尔·亚当1986年发表的《未来夏娃》这部科幻小说中，作者利尔·亚当将外表像人类的机器起名为Android。这就是Android小人名字的由来。 05年，Google低调收购了一家公司。07年，Android系统首次亮相。08年，Google推出Android 1.0。11年，Android系统全球份额位居第一。 自从Android发布以来，凭借开源的优势，迅速占领了市场。又因为使用Java就可以开发Android应用，软件开发者们也迅速的涌入到Android开发的潮流之中。 序言我从大二开始接触Android，中间断断续续做了几个项目。中间有很长一段时间感觉到了瓶颈，无法进步。所处的状态就是做项目的话能做，该实现的功能一般都实现得了，但是总感觉写的代码灵活性、扩展性方面甚是欠缺。后来静下心对framework源码进行一些学习后，才感觉有所进步，突破了之前的瓶颈，也感觉重回到了一开始进步快速的状态。目前也在继续探索系统源码，思考一些设计模式和架构方面的东西。 另外高人指点或有人一起学习特别重要，而我之前在这方面做得确实不足，希望之后能和大家一起讨论一些问题。 最近在探究Android拉活机制和Android插件化开发。晚点我会整理成文章发出来。之后我也会写一些Android开发中实用的技巧，Android进阶需要掌握的知识和思想，希望能尽快和大家分享和交流。 挖了很多坑，希望填的满。 简单来说，Android开发其实就是编写Java代码，配合xml文件和图片资源，然后打包安装到Android系统的软件。 以下是我总结的Android开发涉及知识的简要内容，供大家参考。 准备 Android历史 Android已发布版本及更新历史 开发语言：Java基础、C++基础（JNI） 系统架构简介 开发环境、AndroidStudio简单使用，AS插件使用，命令行工具 基础 界面：四大组件、布局、UI组件、自定义view、动画 网络：okhttp、Gson等 数据持久化：SharedPreference、SQLite、文件等 进程、线程、同步、异步 辅助开发工具的使用：依赖管理Maven、构建工具Gradle、Crash处理、调试、日志 APP打包、上传、升级 进阶Framework底层代码角度重新思考Android开发 AIDL、Binder、多进程 事件分发、view handler、looper、MessageQueue 动画细节 性能优化 JNI 开源框架、开源库：OKhttp、EventBus、Retrofit等 注解 优化工具：Hierarchy Viewer、OOM检测优化工具MAT、Lint 设计模式、架构 Activity启动模式、标记位、Intent Filter Service启动、绑定 多线程：AsyncTask、HandlerThread、IntentService 线程池 系统核心机制 AMS、PMS Window和View的关系 四大组件工作过程（Activity启动过程) SystemServer启动过程 其他需求不同，需要掌握的技术不同 硬件调用相关（传感器、定位等） 持续集成 版本管理Git Material Design 第三方服务：广告、Crash、统计、应用分发、数据存储、推送、分享、便捷登录、Google Play服务 Android安全、反编译 增量更新、热更新 插件化 学习资源看书籍、博客、Android training &amp; guide、源码 写 总结很重要 博客、笔记 一些资源 http://gityuan.com/ CSDN博客：罗升阳、邓凡平、任玉刚 简书上也有很多高质量的博客 基础书籍《Android4高级编程》《第一行代码》《Android 50 hacks》 进阶书籍《Android开发艺术探索》《Android源码设计模式》《Android系统源代码情景分析》 其他书籍《代码大全》《重构》《深入理解Java虚拟机》《Java并发编程》《efficient Java》等]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cocos 中 JSC 文件解密和重新加密的脚本]]></title>
    <url>%2F2019%2F03%2F09%2FCocos%E4%B8%ADJSC%E6%96%87%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%92%8C%E9%87%8D%E6%96%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[好久没更，正好最近毕业生找工作的季节，几篇面经的文章多了一些赞，也顺带涨了几个粉。 从文章统计数据来看，浏览量比较多的还是面经，而非平常的技术文章。以前在文章里也说过，一个人能挣的钱取决于他的社会价值，一个人能否找到好工作在于其本身实际素养。虽然面试时能够包装一下，但是过度包装也很容易被戳破。面经固然可以起到一些作用，但是读一些技术文章和实践编码才是成长的关键。希望找工作的同学读面经时，遇到不会的一定要逐个突破掌握，才能让面经起到应有的作用。否则纵然你读100篇面经，也涨不了知识。 另外，做一个项目不仅仅包含写代码这一部分。比如Android项目还要包含自动化构建等等内容，一些操作靠人来完成耗时耗力，如果能够实现一些能够解放人力、提高效率的脚本是十分有用的。 最近写了一个Cocos中 jsc 文件解密和重新加密的脚本，可以提升Cocos中比如热更新时的打包效率。项目地址：点击跳转GitHub 简介通过阅读Cocos2dx源码发现，其脚本加解密用的就是xxtea加密和解密。 CocosCreator构建过程为： 工程用到的所有js脚本聚合为project.js等几个脚本 如果勾选“Zip 压缩”选项，会进行压缩project.js，会减少很多体积，进而可以减少包大小 使用xxtea进行加密上述文件，生成project.jsc 将project.jsc打包到apk、ipa等安装包中 在程序运行时，正好做了相反操作： 使用xxtea进行解密 如果勾选“Zip 压缩”选项，进行解压缩 调用js代码 此脚本就是用于CocosCreator加密编译后 jsc 文件解密为 js 文件和 js 文件加密为 jsc 文件。 CocosCreator构建时，是否勾选Zip压缩选项决定了使用脚本的参数不同。在CocosCreator的构建面板下图的位置中，查看加密密钥和是否开启Zip压缩。 此脚本在 macOS High Sierra 10.13.6 系统，Python 2.7 下运行正常，其他环境未测试 使用说明命令行使用： 如果使用加密功能，第二个参数设置为 encrypt；如果使用解密功能，第二个参数设置为 decrypt。此参数为必选参数 如需设置加密密钥，添加 –key 或 -k 参数，并跟上加密密钥字符串。如不设置，会在命令行中提示输入 如需设置为非压缩方案，添加 –nozip 或 -n 参数，并设置为 true。如不设置，默认为压缩方案 非压缩方案是指Cocos编译时没有勾选“Zip 压缩”选项 找到CocosCreator编译出来的 .jsc 文件，一般在工程目录下 build/jsb-default/src 文件夹下。你可以在脚本运行时，根据提示输入文件的路径来指定对应文件。也可以添加 –path 或 -p 参数，设置为文件路径。如不设置，会在命令行中提示输入 运行脚本即可 encrypt：解密后文件路径为 decryptOutput/decrypt.js decrypt: 加密后文件路径为 encryptOutput/projectChanged.jsc 举例： ./edc.py encrypt –key yourkey –nozip true ./edc.py decrypt –nozip true ./edc.py decrypt 其他Python脚本中引用： 下载edc.py文件放到你的脚本目录下，通过 import edc 进行导入 直接调用 edc.decrypt(is_zip, key, jsc_path) 或 edc.encrypt(is_zip, key, js_path) 即可，可参考 edcExample.py 文件 如果是非交互式脚本，请务必在调用方法时传入有效的参数，并保证其正确性 参数说明 参数名 缩写 是否必须 默认值 encrypt/decrypt 无 是 - –key -k 否 - –nozip -n 否 false –path -p 否 - 参考文章 形同虚设的cocos默认加密 cocos2dx lua 反编译 版权声明本文首发自简书：搜索作者 QinGeneral同步发于CSDN博客：搜索作者 迷失同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Cocos</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从 Android 源码来看 “Builder 模式”]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BB%8E%20Android%20%E6%BA%90%E7%A0%81%E6%9D%A5%E7%9C%8B%20%E2%80%9CBuilder%E6%A8%A1%E5%BC%8F%E2%80%9D%2F</url>
    <content type="text"><![CDATA[本文主要解释什么是Builder模式，及其作用。然后结合 Android 源码来看一下Builder模式的实现。 什么是Builder模式Build 是构建、建造的意思，Builder 模式又称建造者模式。 Builder模式中包括两个核心元素：产品和建造者。这两者可以比作房屋和砖瓦匠。在建造房屋这个过程中，如果建筑公司直接操作房子，除了要对墙壁的颜色、地板的材质、屋顶的形状作出选择外，还要注意建造房屋时的顺序：先打地基、再垒墙壁、最后封顶等等。记住构建房屋的每一步及其顺序，这对建筑公司来说是十分麻烦的。而如果建筑公司引入砖瓦匠的角色，将构建房子的流程等工作交给砖瓦匠，自己只需告诉砖瓦匠：“我要木质地板、白色的墙壁、红色屋顶”即可，构建房屋所涉及的复杂流程就无需关心。另外，当建造房屋的流程发生变化时，建筑公司仍然只需告诉砖瓦匠：“我要木质地板、白色的墙壁、红色屋顶”，而不需作出任何改变。 由上边的比喻可以看出，Builder模式是将房子本身的设计、表示和房子的构建进行分离。不使用此模式，开发者不仅需要关注一个产品的表示，比如AlertDialog的title、button等界面元素，还要关注构建产品的步骤。更加重要的是，如果建造房屋的流程发生变化，不能够再按照以前构建产品的方式创建产品的话，开发者就不得不修改代码来适配新的构建流程。Builder模式可以解决这些问题，为产品增加Builder角色，将构建过程交给Builder实现，开发者只需关心产品属性的设置即可。 就像建筑公司雇佣砖瓦匠需要发工资一样，使用Builder模式的缺点便是需要为增加的Builder对象分配内存。 源码中的Builder模式在Android源码中，比较常见的是AlertDialog的使用。代码如下： 12345val builder = AlertDialog.Builder(this)builder.setMessage("message")builder.setTitle("title")...builder.create().show() 以上代码，无论构建AlertDialog的流程如何变化，都无需改动代码。因为构建过程在12345678910111213141516171819202122232425262728293031323334353637383940414243444546AlertDialog的核心代码如下：```Javapublic class AlertDialog extends AppCompatDialog implements DialogInterface &#123; final AlertController mAlert; protected AlertDialog(@NonNull Context context) &#123; this(context, 0); &#125; @Override public void setTitle(CharSequence title) &#123; super.setTitle(title); mAlert.setTitle(title); &#125; ...//省略部分类似setTitle()的代码 public static class Builder &#123; private final AlertController.AlertParams P; private final int mTheme; public Builder(@NonNull Context context) &#123; this(context, resolveDialogTheme(context, 0)); &#125; public Builder setTitle(@Nullable CharSequence title) &#123; P.mTitle = title; return this; &#125; ...//省略部分类似setTitle()代码 public AlertDialog create() &#123; final AlertDialog dialog = new AlertDialog(P.mContext, mTheme); P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); ...//省略部分代码 return dialog; &#125; ...//省略部分代码 &#125;&#125; Builder 是在 AlertDialog 内部实现的静态类，其主要工作便是通过一系列set方法对 AlertController.AlertParams 对象进行设置，AlertParams类中包含了所有AlertDialog视图属性对应的成员变量，比如mTitle、mMessage等等。然后在create()方法中进行AlertDialog的构建。 Builder模式的实现比较简单，但是除了“AlertDialog初始化十分复杂，参数繁多”这种应用场景之外，还可以在以下场景中使用Builder模式： 构建产品时，不同构建顺序会对产品产生不同的效果 构建产品时，不同构建元素会对产品产生不同的效果 相同方法在以不同执行顺序执行时，产生不同结果 总结Builder模式用于将产品的构建和展示分离。这样开发者就不必知道产品构建细节，只需对产品的外观进行设计、配置即可。无需担心产品构建流程发生变化。其缺点是需要为Builder对象分配内存。但这也是大多数设计模式的共同缺点。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 面试：网络基础会问哪些问题及解答]]></title>
    <url>%2F2019%2F03%2F09%2FAndroid%20%E9%9D%A2%E8%AF%95%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%BC%9A%E9%97%AE%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[Android面试中问到网络基础，基本是围绕OSI七层模型或者是TCP/IP四层模型展开的，主要包括各层名称及功能、每层有哪些协议。 另外会深入考察应用层和传输层。 应用层：（HTTP、DNS等） HTTP报文格式、头部有哪些字段 HTTP状态码 HTTP和HTTPS的区别 HTTPS中SSL/TLS加密的握手过程 HTTP一次连接的具体过程 GET、POST的区别 DNS解析过程 Cookie、Session原理 传输层：（TCP、UDP等） TCP/IP四层模型（和OSI的层次对应关系） TCP三次握手、四次握手的过程，状态变化和原因 TCP、UDP区别 TCP拥控、流控原理 Socket原理 以下是正文，其中空出的标题是我目前还没有整理完毕，或者是整理不够完整的内容。在对应内容完善后会进行更新。其中包括Cookie、Session原理，TCP拥控、流控原理，Socket原理。 OSI七层模型及其功能 层级 功能 应用层 允许访问OSI的手段 表示层 对数据进行翻译、加密、压缩 会话层 建立、管理、终止会话 传输层 提供端到端的可靠报文传递和错误恢复 网络层 负责数据包从源到宿的传递和网际互联 数据链路层 将比特币组装成振和点到点的传递 物理层 通过媒介传输比特，确定机械及电气规范 TCP/IP 四层模型及对应协议TCP/IP中的应用层对应OSI中的应用层、表示层、会话层，网络访问层对应OSI中的数据链路层和物理层。 层级 协议 应用层 HTTP、DNS、FTP、WWW 传输层 TCP、UDP 网络层 IP 网络访问层 ARP 注：DNS作用是将域名转为IP地址；ARP作用是将IP地址转为MAC地址 HTTP报文格式、头部有哪些字段先说一下HTTP。HTTP：HyperText Transfer Protocol 超文本传输协议，处于应用层，基于请求响应模式，无状态协议。URL：Uniform Resource Location 统一资源定位符，就是常说的网页地址。 HTTP报文 请求报文 报文头部 请求行：包括请求方法类型：GET、POST等，请求地址，协议版本 请求头部字段 通用头部字段 实体头部字段 其他 报文主体：包括如POST中的请求参数、文件上传数据、邮件传输数据等内容 响应报文 报文头部 状态行 响应头部字段 通用头部字段 实体头部字段 其他 报文主体：包括网页正文等内容 根据上述内容，HTTP头部字段包括： 请求头部字段：补充请求的附加内容、客户端信息、响应内容相关优先级等。有Accept、From、Host等字段 响应头部字段：补充响应的附加内容 通用头部字段：请求报文、响应报文都会使用，包括Cache-Control字段，作用是控制HTTP缓存机制 实体头部字段：补充资源内容的更新时间等 HTTP状态码 状态码 含义 1xx 信息性状态码 2xx 成功状态码 3xx 重定向状态码 4xx 客户端错误状态码 5xx 服务器错误状态码 HTTP和HTTPS的区别简单来说，HTTPS是加密的HTTP。HTTPS = HTTP + SSL/TLS HTTPS使用SSL/TLS进行加密，这既是它的优点也是它的缺点，加密使HTTPS的安全性大大提高，但是加密的过程也导致通信过程中性能的下降。但总的来说用失去的一点点性能换来极高的安全性是非常值得的，苹果和谷歌也大力支持HTTPS的使用。 HTTPS的关键是加密过程，见下一标题。 HTTPS中SSL/TLS加密的握手过程以下的C代表Client客户端，S代表Server服务端。 C告诉S：协议版本号，支持的加密方法，以及自己生成的随机数 S确认加密方法，给C方松证书和自己产生的随机数 C确认证书有效性，产生新的随机数，并使用数字证书中的公钥加密随机数，发送给S S使用对应的私钥解密得到C发过来的随机数 C和S使用约定的加密方法，使用前面的三个随机数，生成对话密钥，然后用此密钥加密接下来的整个对话过程 总的来说，整个过程就是使用非对称加密算法交换“对话中要使用的对称加密算法的密钥”，然后使用对称加密算法进行对话。 注： 加密算法分为两种：对称和非对称 对称加密是指对话双方使用同一密钥进行加密和解密。特性是速度快，但存在如何安全确认密钥的问题。 非对称加密是指拥有两个密钥，公钥和私钥。公钥加密的内容只有私钥能够解密，私钥加密的内容只有公约能够加密。C向S发送内容时使用S的公钥加密，这样就只有持有对应私钥的S能够解密。特性是安全，但速度慢。同时存在如何证明公钥是S的问题，因为可能有人从中间劫持，伪装S发送劫持人的公钥。为了解决这个问题，引入了数字证书来保证公钥的有效性。 SSL/TLS结合了两个加密算法的优点，利用非对称加密的安全来交换对称加密的密钥，然后利用对称加密的速度快来对这个会话进行加密。 HTTP一次连接的具体过程域名解析（DNS）——&gt; TCP三次握手，建立连接 ——&gt; 发起HTTP请求 ——&gt; 服务器响应请求，返回数据 ——&gt; 客户端处理数据 ——&gt; 合适时刻四次握手，断开连接。 这里可能会继续追问诸如DNS解析过程、三次握手四次握手过程和原因等等问题，解答见下文。 GET、POST的区别 GET请求可以被浏览器缓存，POST不可以 POST安全一些，因为GET请求都在URL中，也会被浏览器保存记录；而POST请求可以放到Body中 POST可以用RequestBody传输更多的数据，GET的数据量受到URL长度限制 POST支持更多编码，且不对数据类型限制 GET的目标功能是查询数据，POST的目标功能是修改数据，或者上传数据 DNS解析过程DNS功能是将域名解析为IP地址。 查找浏览器缓存，是否有解析记录，没有则进入第二步 查找系统缓存，是否有解析记录，没有则进入第二步 给配置的DNS服务器（LDNS）发送请求，LDNS查找到则返回 LDNS没有找到时会请求RootServer，返回一个顶级域名服务器 LDNS请求顶级域名服务器，返回NameServer地址 NameServer返回IP给LDNS，LDNS会进行缓存 LDNS返回给用户 注：各级都会对IP的解析进行缓存，同时会根据各自的缓存策略对一些记录进行清理 Cookie、Session原理TCP三次握手、四次握手的过程，状态变化和原因 为什么需要三次握手建立连接？为了防止已失效的连接请求报文段突然又传到了服务端，服务端以为要建立连接，造成资源浪费（无效连接）。发生场景是，客户端发送第一个建立连接的请求由于网络原因服务端一开始没有接收到，因此客户端发了第二个连接请求，这个请求成功，建立起了连接。但是第一个请求后来又到达服务端，如果没有第三次确认，服务端将多形成一个连接，造成资源浪费。 为什么需要四次握手断开连接？断开连接时，分为两个阶段。一次是客户端通知服务器，告知自己不会再发送数据。注意，此时服务器仍可以发数据给客户端。第二次是服务器告知客户端自己不会再发送数据。要弄清楚的是，断开时，任意一方都可以主动断开，表明自己不再发送数据，但仍可接收数据。所以中间的FIN和ACK不能合并。另外每次断开连接需要FIN请求 + ACK，所以断开需要四次。 TIME_WAIT等待2MSL的意义？ 确保连接可靠关闭，防止最后一个ACK的丢失。 避免套接字混淆（同一个端口对应多个socket） 注：主要目的是，对客户端会发的ACK丢失的情况做处理，可以在服务端再次发送FIN时回发ACK。 TCP、UDP区别 特性 TCP UDP 有无连接 有 无 数据有序性、完整性 有 无 效率高低 低 高 数据大小 无限制 每个数据包64K 应用方面 可靠通信 不需要可靠通信 TCP拥控、流控原理Socket原理 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[四步准备 Android 面试]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%9B%9B%E6%AD%A5%E5%87%86%E5%A4%87%20Android%20%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[各大公司内推进行的如火如荼，再过一段时间就是校招。 面试可以说是学生步入社会的一场考试，只不过是笔试+多次面试（口头考试）的结合体，只要时间不冲突，可以多考几次，秋招不行还有春招。 笔试形式类似在学校的考试。面试相对来说形式新一些，难度更大一些，考察的范围不仅仅是专业知识的掌握，还包括性格、抗压能力、表达能力、随机应变能力等等。 但是归根到底，找工作的过程就是解决一个相对复杂问题的过程。可以按照以下四部进行准备： 定义问题 划分问题 逐个突破 系统化 接下来一步步的看一下具体细节。 1. 定义问题首先，定义一下我们解决的是什么问题。在这里，因为我们是Android方向，所以可以简单定义为：“我们要找到一个Android方向的工作（或相关的工作），工作要尽量好”。 这个定义很模糊，什么是尽量的好呢？有的人看中薪资，有的人看中五险一金，各种福利等等。在这里，我们不考虑个人主观因素占比较大的问题。我们只考虑更加可控的东西。就是通过个人努力可以获得效果的问题。 我们再思考一下“找到一个Android方向的工作”起决定性的因素是哪一个呢？答案是面试。当然一个人过去做过的项目，拿过的奖也至关重要。但是到了这个马上就要面试的时间节点，过去的已经过去，无法改变，能控制的只有现在。没有项目无关紧要，关键的是现在如何准备面试。 目标：我要通过面试，拿到offer（或者我要通过多家公司面试，拿到多家公司的offer，选择最合心意的公司去工作）。当然，这句话表达的太宽泛，并没有什么指导意义。定义问题很重要，而更重要的是如何划分问题，这一步才是具有指导意义，能够落到实践中去的内容。 2. 划分问题Android面试需要准备内容的大致划分：（括号内为重要程度，最多 5 颗星） Android相关知识、Java相关知识、设计模式（5） 算法、数据结构（5） 如何写简历、如何面试（4） 项目、比赛获奖（4） 操作系统、网络、数据库（3） 细分以下细分内容，网络等计算机基础方面还不是很全面，持续更新中。我会逐步更新各个知识点相关博客或资源，如果需要，建议关注。 Android Context的理解 Activity生命周期、启动模式 IntentFilter匹配规则 IPC：Serialzable、Parcelable、Binder、Socket View事件体系 View绘制流程 RemoteViews（不重要） Drawable（不重要） 动画、绘图 window、wm、wms 四大组件启动、工作流程（Activity至少看一下，AMS） 消息机制：looper、handler、MQ 线程、线程池、多线程 bitmap加载、缓存：LRUCache、DiskLruCache、LinkHashMap CrashHandler（一般） multidex（一般） Fragment、Service、SQLite、Webview 内存泄漏：原因、解决方法 ANR的原因、解决方法 开源库（一般要求看过源码，知道原理）：Retrofit、RxAndroid、EventBus、Picasso（优点）、OKhttp3 持续集成Jenkins（不重要） 单元测试、测试用例（一般） 插件化：Atlas、OSGI（一般） Java Java基础：比如接口和抽象类的区别等 Java内存管理：工作内存和主内存等 垃圾回收：回收算法、如何判断对象可以回收、新生代老年代等 并发 锁：sychronized、lock（CAS） volatile 并发集合：CopyOnWriteArrayList、ConcurrentHashMap、RemoteCallbackList（Android的IPC用到）、LinkedHashMap 集合 Map、Set、List Queue、Stack HashMap、HashTable、ConcurrentHashMap：实现原理，区别等 LinkedHashMap 设计模式（六大原则：SOLID + 迪米特） 单例模式：获取各种service 工厂方法：activity、service（onStart） 责任链：Android事件分发 builder：dialog、Picasso 观察者：listview更新、EventBus 适配器：listview adapter 算法、数据结构 排序 冒泡排序 选择排序 归并 堆排序 插入排序 快速排序 希尔排序 桶排序 基数排序 字符匹配：KMP算法 二分查找 二叉树遍历、翻转、重构；二叉查找树 红黑树 AVL树、哈夫曼树、B树（一般） 网络 OSI七层模型、各层功能、各层协议 TCP/IP四层模型 TCP三次握手、四次挥手 TCP、UDP区别 Http、Https区别 操作系统、数据库 线程状态及其切换 线程、进程区别（数据库重要程度相对低一些，正在整理中，后续会更新） 简历、面试、项目篇幅较大，会有另外博客进行探讨，敬请关注 3. 逐个突破可以自己去网上找一些博客、书籍，进行各个知识点的突破，要有耐心，找到一个心仪的工作非一日之功。一方面，我会陆续更新一些专业知识和面试相关的博客。另一方面，把我自己的一些资源分享给大家。 博客GitYuan（gityuan.com）、罗升阳（CSDN）、邓凡平（CSDN）、任玉刚（CSDN） 书籍Android 4高级编程、Android开发艺术探索、Android源码设计模式、Android 50 hacks、Android应用性能优化最佳实践、Efficient Java、深入Java虚拟机、Java并发编程、Think in Java 刷题LeetCode、牛客网 4. 系统化又是一个很大的主题，在另外博客中进行探讨，后续会更新，敬请关注 。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于张小龙谈互联网本质的思考]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%85%B3%E4%BA%8E%E5%BC%A0%E5%B0%8F%E9%BE%99%E8%B0%88%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%AC%E8%B4%A8%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[张小龙说互联网的本质是减少人与人之间的信息不对称，可以说现在只要连上了互联网你就拥有了别人拥有的信息。 而信息变成知识需要“筛选”的过程。 当下人们面对繁多的信息，选择阅读哪些内容更加重要。人们需要加强自己的判断力和选择力，从众多果实中挑选最美味的果子来满足自己。不难想象，吃一生坏掉的果子对自己有多不公正，谁都不希望垃圾信息充斥自己的人生。 当然信息优劣的很多人会有主观的判断，但从思想自由的角度来看，一些书籍、新闻只会让人更加偏执、带有偏见，甚至让你在现实中做出错误判断进而影响一生。 这里可以通过使用更好的搜索引擎，大咖推荐等方式找到优质信息源。书籍、国外新技术博客等都是优质信息的一种方式，而如微博、知乎、微信朋友圈中的优质信息也是少之又少，需要花大量时间和精力去分辨和判断。 另一方面，可以通过技术层面来解决垃圾信息的问题。抖音优质的“推荐算法”是这个技术的体现之一，只是方向并不是“优质内容”。那么在“能让人们生活更幸福”的知识上也是可以通过技术来实现的，这一点又可以和现有机器学习等技术相结合。之后出现判断信息优劣的服务也并不需要惊讶，因为这是一部分追求甜美果实人的刚需。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Replugin 插件管理与权限管理]]></title>
    <url>%2F2019%2F03%2F07%2FRePlugin%20%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[插件化能够提高我们程序的拓展能力，提高灵活性。Android中比较有特点的一个插件化框架是RePlugin。 RePlugin分为宿主和插件的概念。一个APP由 1个宿主 + n个插件组成。宿主的主要功能是管理插件的安装、卸载、更新；插件权限管理等等（当然也可以将管理功能作为一个插件）。那APP下的每一个模块就可以对应一个插件。当你需要添加功能、更新功能的时候，直接把新的插件或更新后的插件发布到线上即可。 插件入门教程请 点击查看。 本文包括以下内容： 插件安装、更新、卸载 线上插件：服务器管理插件信息 插件权限管理 1. 插件安装、更新、卸载插件的基础操作包括插件的安装、更新、卸载等，RePlugin不支持插件的降级。RePlugin对此进行了很好的封装，仅需调用以下代码。 RePlugin中的插件分为外置插件和内置插件。内置插件即随应用安装包（宿主）附带的、在工程app/src/main/assets/plugins文件夹中的插件，内置插件的名称格式为[插件名].jar，文件名即为程序中的插件名。外置插件即应用运行时从sdcard安装的插件。另外，内置插件更新后也会变成外置插件。 安装与升级插件的安装与升级是调用同一代码即可。如果插件正在运行，则不会立即升级，而是“缓存”起来。直到所有“正在运行插件”的进程结束并重启APP后才会生效。 1RePlugin.install("sdcard路径"); 另外可以在插件安装之后加入以下代码，提前释放插件的文件，提高插件的启动速度。因为在插件安装更新之后，不做任何操作，第一次启动会很慢。 12345PluginInfo pluginInfo = RePlugin.install("插件sdcard路径");if (pluginInfo != null) &#123; RePlugin.preload(pluginInfo);&#125; 卸载要卸载插件，则需要使用 RePlugin.uninstall方法。只需传递一个“插件名”即可。 1RePlugin.uninstall("pluginName"); 启动调用以下代码启动插件中的Activity 1RePlugin.startActivity() 建议在用户第一次启动应用时，主动对所有的内置插件调用 preload 方法，并在界面显示处理进度。否则，用户每当第一次打开应用中的插件时，框架会先解压插件，耗时比较长 2. 线上插件为了让应用真正拥有灵活更新其功能的能力，就需要把一些插件放到服务器上，按需下载、安装插件。 服务器端就不再详说，主要是可以查看插件列表，下载插件，插件权限管理等功能。下载功能的简单实现可以参考博客 Tomcat文件下载服务器 主要说一下服务器插件信息的数据结构，当然不同的需求有不同的结构。 123456789101112131415[&#123; "showName": "插件展示给用户的名字", "realName": "程序中的插件名", "isBuiltIn": "是否内置", "updateInfo": "更新信息", "iconTypeAndName": "插件图标名字mipmap/ic_launcher", "version": "插件版本号", "host2PluginActivities": [ &#123; "name": "插件中可以被启动的activity" &#125; ]&#125;,...] 3. 插件权限管理当一个应用需要对不同用户控制其权限时，就要在服务器端对插件的权限进行管理。比如说公司内部软件需要对不同角色的人员给与不同的功能，限制其对其他部门功能的使用。 简单描述一下插件的权限管理功能。主要就是实现能够控制不同用户使用不同组合的插件。 可以采用以下的关系： 就是说“权限”是插件和用户的连接点，每个插件拥有一个对应的权限，一个用户拥有多个角色，一个角色对应多个权限。 那我们首先需要有三张表：用户表、角色表、插件信息表。我对三张表的处理和说明如下 用户表用户表在插件管理中拥有字段 repluginRole 即可，代表用户的插件角色。 角色表repluginRole 字段 说明 id 角色id roleName 角色名称 permission 所拥有的权限 插件信息表 repluginPluginInfo 这里简化其他字段，只保留插件权限相关字段 字段 说明 id 用户id requirePermission 插件要求的权限 isOnline 插件是否在线，即是否发布 那么去服务器获取某员工插件列表的过程如下： 获取该员工的角色，repluginRole字段 通过repluginRole获取该角色所拥有的权限列表 获取插件列表，用上一步的权限列表去匹配各个插件的权限，如果isOnline为true（插件已上线）且拥有插件权限就放入插件列表 Tips目前RePlugin存在bug（2.2.1版本），即安装、更新插件并重启App关闭后，读取插件信息出错，无法加载刚刚更新的插件。 解决： 关闭应用时，手动杀死：GuardService进程即可。GuardService进程为RePlugin框架后台处理插件安装等操作的进程。官方回复，2.2.2版本已经修复，但还未放出此版本。 在Host工程的app module对应的build.gradle中设置persistentEnable = false，使用主进程为插件管理进程。这样做的原理同上，在关闭APP的时候关闭框架的插件管理进程。但是我这样做的时候这会导致APP启动特别慢，运行卡顿，还可能会崩溃。推荐用方法1，虽然这样做需要去处理各种APP关闭的情况。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 插件化框架 RePlugin 初探]]></title>
    <url>%2F2019%2F03%2F07%2FAndroid%20%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%20RePlugin%20%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[为什么要使用Android插件化框架？写软件时，软件的扩展性至关重要。而软件的扩展性跟其代码的解耦程度相关。解耦程度大，就是模块化强。解耦程度小，即模块化弱。 插件化框架RePlugin，所做的就是将软件解耦，实现了代码的模块化。这对软件本身的后续开发、功能添加等，是十分有利的。大大降低了扩展软件的成本，代码的清晰度也提高了。 RePlugin带来的好处不止这些，它还给应用提供了“不用更新APP，直接更新、添加功能”的能力。能帮助我们以更低的用户成本，更加快速的进行迭代。 Android插件化框架要解决什么问题？从Android的FrameWork结构来看，Android插件化都要解决基本的三个问题： 资源管理，比如drawable、string等资源 四大组件的生命周期，主要是activity、service组件 ClassLoader类加载 目前已经开源的Android插件化框架开源的插件化框架： Atlas（阿里 点击访问GitHub） VirtualAPK（滴滴 点击访问GitHub） RePlugin（360 点击访问GitHub） 其中，Atlas主要概念是组件化。RePlugin的优点是只hook了一处——ClassLoader。所以稳定性极强，适配十分简单。 RePlugin 两个主要概念RePlugin分为宿主和插件的概念。一个APP由 1个宿主 + n个插件组成。宿主的主要功能是管理插件的安装、卸载、更新；插件权限管理等等（当然也可以将管理功能作为一个插件）。那APP下的每一个模块就可以对应一个插件。当你需要添加功能、更新功能的时候，直接把新的插件或更新后的插件发布到线上即可。 RePlugin 宿主配置教程 添加 RePlugin Host Gradle 依赖 在项目根目录的 build.gradle中添加 replugin-host-gradle 依赖： 123456buildscript &#123; dependencies &#123; classpath 'com.qihoo360.replugin:replugin-host-gradle:2.2.1' ... &#125;&#125; 添加 RePlugin Host Library 依赖 在 app/build.gradle 中应用 replugin-host-gradle 插件，并添加 replugin-host-lib 依赖: 12345678910111213141516android &#123; // 要配置applicationId defaultConfig &#123; applicationId "com.qihoo360.replugin.sample.host" ... &#125; ...&#125;// apply语句必须放置到android标签之后，以读取applicationId属性apply plugin: 'replugin-host-gradle'dependencies &#123; compile 'com.qihoo360.replugin:replugin-host-lib:2.2.1' ...&#125; 配置 Application 类 让工程的 Application 直接继承自 RePluginApplication。 123public class MainApplication extends RePluginApplication &#123;&#125; 在AndroidManifest中配置这个Application。 123&lt;application android:name=".MainApplication" ... /&gt; 只需三步就把RePlugin的宿主配置好了，之后即可在宿主的代码中调用RePlugin相关api，启动、管理插件。 注：如果插件需要使用宿主的依赖库，需要在宿主的Application类中加入以下代码把”插件使用宿主类”选项打开，默认是关闭 1rePluginConfig.setUseHostClassIfNotFound(true); RePlugin 插件配置教程 项目根目录的build.gradle，添加以下代码 123456buildscript &#123; dependencies &#123; classpath 'com.qihoo360.replugin:replugin-plugin-gradle:2.2.1' ... &#125;&#125; 在app/build.gradle中，添加以下代码 123456apply plugin: 'replugin-plugin-gradle'dependencies &#123; implementation 'com.qihoo360.replugin:replugin-plugin-lib:2.2.1' ...&#125; 两步即可将插件配置好。编写插件代码之后，将插件工程导出apk，改名为 [PluginName].jar 放到宿主工程的assets/plugins文件夹，启动APP即可。 注： 配置插件别名时，在插件的AndroidManifest.xml中，添加以下内容即可（和activity标签并列） 1234&gt; &lt;meta-data&gt; android:name="com.qihoo360.plugin.name"&gt; android:value="[你的插件别名]" /&gt;&gt; 插件的版本号即app/build.gradle中配置的 versionCode 更新插件时迭代插件版本号，重启应用，框架会自动重载、更新插件（RePlugin是这样设计的，但是有bug，解决方法见下，新版本的RePlugin已解决此bug但未发布，可自行去官网下载编译） 当前版本的RePlugin框架的bug：更新插件后，重启应用不会自动加载插件。要解决这个bug，需要在APP关闭时，同时将:GuardService进程（这是插件管理进程，默认启动）关闭即可。 compileOnly(provide) : 库只用于编译期，不会打入apk中；implement(compile) : 会打入apk中。在插件使用宿主的依赖库时，只需使用compileOnly即可，可以减小包的体积 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于写作]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%85%B3%E4%BA%8E%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[读过的书、看过的电影、听过的音乐，就像我置身于撒哈拉沙漠，在一座座小山峰之中留下我的足迹。不时回首，看看走过的路：或心生骄傲，因为我曾驻足历朝历代，看明君暗主与天下分合；或心情忧虑，因为我曾体会过战乱的困苦与亲子分离之痛……而随着时间流逝，各种感情变得不那么分明。沙漠里的风沙来来去去，掩盖着我之前留下的行踪。我在我的坎坷之路上一步一个脚印的徒步，也在这无边的沙漠之中继续行走，继续体验着他人的世界。沙漠之路和我的现实之路互相缠绕，犹如藤蔓在大树上一圈一圈的绕上树梢。藤蔓或勒紧树枝，重新塑造了树本身；或借由枝杈又生新芽。而根部的藤蔓终有老去，沙漠的足迹终会被风沙掩盖。 写作是将千万水滴聚为小溪、河流的利器，在沙漠之中畅快流淌，源源不息。写作也是化沙为水的魔杖，走过的山峰也会混入河流之中，随我一同往前奔流。 你能控制的东西你才真正拥有。过往之山峰虽可时时回忆留恋，却不是你随身物品。只有奔涌向前的河流，才是与你一同向前，需要时可以助你一臂之力的囊中之物。 为何只看过往山川，却不拥有一条自己的河流呢？ 然而不积跬步无以至千里，不积小流无以成江海。没有一点一滴的积累就能写出好文章是不可能的。（古人确实聪慧，“不积跬步”与现在的“一万小时理论”异曲同工，不过国外理论进步的地方是做了详实的实验。）有机会做好一切事情的方法是什么？重复。只要你去反反复复去做一件事，学英语就多读、多看；学编程就多敲代码，多看牛人文章……不愁“大业”不成。重复一件事情确实枯燥，这需要你的耐心去找出这件事情的乐趣，而耐心也是需要你去锻炼才能掌握的能力。等你熟练的掌握一门或多门技能之后，需要的就是一些运气和机遇（而你能看到和抓住机遇的本领也是需要练习的，）然后奋勇而上，由此登上一个台阶，继而为下一个目标努力。有的人说天赋很重要，但已经有实验证明：优秀的人变得优秀靠的是一次次的练习，而非天赋（《异类》一书中已经证实这个观点。）从小天资过人，却恃才傲物不肯下苦功夫最终遗憾一生的例子也比比皆是。 一开始有些人可能羞于把自己的文章拿出来给别人看，这里的关键因素是什么？面子。素有“国人的面子文化”这一名词。但同时因为“面子”误了很多事。 在写博客这件事情上，有几点好想清楚： 没那么多人在乎你 他人的反驳恰恰是你应该思考自己观点的时候，甄别观点优劣，取精华而用之不正是皇帝干的事 你的文章如果能够给一些读者带来振动或者帮助，岂不是皆大欢喜 十年磨一剑，写作就是你思想的磨刀石 书中自有黄金屋，写作自然是知识变现的一种方式 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于如何写好简历的指北]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E7%AE%80%E5%8E%86%E7%9A%84%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[经过忙碌的校招，发现现在计算机行业竞争真的激烈。在这段时间也对简历、面试、专业技术上做了很多阅读、思考和实践。在简历上，看了教学视频，数篇博客，听了live直播。现在把我阅读的一些东西和自己关于如何写简历的心得总结一下，分享给大家，供参考。 大家都知道，在找工作时，要想进入面试的前提是——把简历写好。 对于简历来说，最重要的东西是内容。简单来说，写好简历就是让简历筛选者明白你和他想招的人在能力上匹配度较高。另外要注意的是，校招简历一般一页，社招简历三页左右，这就要求你能够简洁的突出自己的亮点，不求全面，而求专一。全文做到逻辑清晰无废话。 内容概要： 简历给谁看 简历必备信息 简历优化 要注意的地方 一、简历给谁看 是谁筛选你的简历？ HR。 HR是怎么筛选简历？ 了解各部门招聘需求 获取简历（外部 + 内推） 关键词筛选，扫描式阅读 HR最在意什么内容？ 岗位匹配度 工作、教育经历 专业技能 你的期望，包括工作地点、行业、薪资 二、简历必备信息 基本信息姓名、性别、联系方式、意向岗位、照片（贴照片要谨慎，只能选择清晰的大头证件照）。 工作、项目经历要列举核心经历，练手的就不要写了。经历在时间上由近到远排版。工作信息包括起始时间、公司部门名称、岗位名称职责，关键业绩。项目经历信息包括项目名称、时间、项目角色、研究成果、获奖情况。这部分表达的主要是自己专业技术上的实践，所以写明成果很重要，有数据的支撑也能大大增加可信度。 教育背景起始时间、学校名称、院系专业、GPA（成绩好的话可以写明成绩和排名）。 相关技能主要包括语言能力、计算机能力、专业证书等。内容不要太广泛，尽量和招聘需求对齐。 工作期望包括地点、行业、薪酬。校招的话薪酬就不要涉及了。 自我描述简洁，不要涉及到自己的缺点，不要表达出自己不行。 附加信息比如博客、Github等等。 校招的话还可以包括： 社团经历：社团名称、职务职责、关键业绩 获奖情况：奖学金、项目获奖、活动获奖、科研论文成果 兴趣爱好：这是让你的形象生动立体的内容，但是要简洁 三、简历优化优化的主要目标还是简洁的表达自己的亮点，尽可能的匹配到公司的招聘需求。 格式的优化 篇幅不宜过长，校招一页，社招三页内 字体字号统一整齐，颜色、字体不要超过2种 色彩设计简洁大方，黑白也不错 逻辑、布局清晰 不要一份简历打天下 按照岗位要求准备内容，提前做足企业招聘需求的功课。项目经历、技能与公司招聘要求对应上去。另外可以巧用专用词汇，描述核心技术。 站在公司的角度考虑问题 这里是说，要主动表达自己和公司的匹配度。比如描述自己能力的稀缺，和专业技术上的优点；利用数据增强说服力；善于概括总结，简洁清晰的表达；自我描述前置，主动留下一个满意的第一印象；说清楚自己的期望。 四、要注意的地方 不要撒谎，有信用问题是职场禁忌 主要信息缺失、错误 无关信息太多，导致亮点不易被发掘 格式或细节粗糙，不要流水账，不要太个性，不要有错别字和网络词汇 用什么邮箱并不重要 附件名字用“应聘XX职位-X年工作经验-姓名”，也可以加上手机号 不要太谦虚，可以适当美化但不要撒谎 常见问题没有相关工作经验怎么办？关键点是在其他领域找到和当前领域相通的方法和思维模式。社招可以写研究成果或者跨行业的项目，和专业领域相关的都可以进行描述；校招可以写社团，学生会经验，体现相应能力的成功实践等等。 前公司没名气怎么办？可以主要谈论实操的经验和价值；谈及一些其他圈子的经历；强调自己在群体中的优异和突出表现。 毕业院校不是一类院校怎么办？看所学专业的排名竞争力；突出自己在校的学习和实践表现。 专业不对口怎么办？写自己对要工作的业务已经具备的能力，比如证书、学习了什么和收获。 频繁跳槽简历怎么写？尊重事实，如果是客观原因，可以简单阐述。 推荐点击查看简历神器 简历模板可以自己在一些网站上付费购买。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 面试：Activity 相关会问些什么？]]></title>
    <url>%2F2019%2F03%2F07%2FAndroid%E9%9D%A2%E8%AF%95---Activity%E7%9B%B8%E5%85%B3%E4%BC%9A%E9%97%AE%E4%BA%9B%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[本文包括以下内容（针对Android面试，部分细节略去）： Activity生命周期 Activity四种启动模式及其应用场景 IntentFilter匹配规则 （Activity和Fragment、Service交互会在其他文章中写到） 1. Activity生命周期 onStart、onStop代表着应用是否可见onResume、onPause代表应用是否在前台 启动A: onCreate -&gt; onStart -&gt; onResumeA启动B：A.onPause -&gt; A.onStop （如果B采用透明主题，则A.onStop不会调用）启动B后，返回A：onRestart -&gt; onStart -&gt; onResumeback键：onPause -&gt; onStop -&gt; onDestroyA启动B，A的onPause执行之后，B才启动。在onPause之中做轻量级工作，能加快B的启动速度 onSaveInstanceState（onStop之前调用，和onPause没有必然的先后顺序）onRestoreInstanceState（onStart之后调用，和onResume没有必然的先后顺序）以上两个方法调用条件： 应用被杀死 配置改变（比如手机方向，添加android:configChanged属性后不会触发，会调用onConfiguration函数） Home键、启动新Activity（单独触发onSaveInstanceState） 2. Activity启动模式四种模式可根据字面意思理解，不过还要注意一些细节 standard 标准模式： 每次启动会创建一个新的Activity A启动B，B会位于A的栈中 默认的启动模式 singleTop 栈顶复用模式 要启动的Activity在栈顶则直接使用，不创建新的Activity 第二次启动在栈顶，会调用onNewIntent、onResume方法，onCreate、onStart不会调用 singleTask 栈内复用模式 要启动的Activity在栈内则直接使用，不创建新的Activity 第二次启动在栈顶，会调用onNewIntent、onResume方法，onCreate、onStart不会调用 可通过TaskAffinity属性指定要启动的Activity将位于的栈名 具有clearTop效果：在栈内，要启动的A之上有B、C，会让B、C出栈，然后复用A singleInstance 单一实例模式 要启动的Activity会新建一个栈，并且此Activity会独占这个栈 注：可以使用 adb shell dumpsys Activity 查看Activity栈信息，来分析Activity启动时栈的情况 应用场景 standard：Activity默认模式，一般Activity都用这个 singleTop：当外界多次跳转到一个页面是可以使用这个模式，比如从一些下拉栏通知界面点击进入一个页面的情景，避免了因为多次启动导致的需要返回多次的情况 singleTask：可用于应用的主界面，比如浏览器主页，外界多次启动时不会受子页面干扰，clearTop效果也会清楚主页面之上的页面 singleInstance：可用于和程序分离的页面，比如通话页面、闹铃提醒页面 注：在A -&gt; B -&gt; C 时，B不要采用singleInstance，否则，退出再打开时，会是B页面（此属性未验证） 3. IntentFilter匹配规则Intent隐式启动的三个属性：action、category、data 匹配规则action：代码中有一个及以上与“xml过滤规则”中的相同即可category：代码中所有的必须与“xml过滤规则”中的相同data：同action 注：代码中隐式启动时，会默认添加android.intent.category.DEFAULT，所以xml必须含有此属性才能隐式启动Service尽量采用显示启动 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于解决 Markdown 文章图片问题]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%20MarkDown%20%E6%96%87%E7%AB%A0%E7%9A%84%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Alfred 是 Mac 上的利器，敲击键盘之间就可以帮你打开应用、浏览文件夹、文件内搜索、执行终端命令，还可帮你做一些繁复但有规律的事情。 用 MarkDown 写文章时，就会碰到『插入图片』这件繁复但有规律的事。在文章中插入一张图片的流程是： 找到图片 上传图片 获取图片链接 为了写文章时方便插入图片，或者在其他用途中使用图片链接，最近写了一个 Alfred workflow，名叫 workflow 文件和相关代码已放在 GitHub ，[点击查看 SmartPic](https://github.com/QinGeneral/SmartPic)。1234567891011121314151617181920212223242526272829303132333435363738394041以下是该工具的简介和使用方式。# SmartPic 简介和使用SmartPic 是一款 Alfred workflow，可以方便大家上传图片到云上，并获取图片链接，可用于 Markdown 写文章时添加图片或其他用途。&gt; 注：SmartPic 基于 Python 2.7，请确保已安装 Python。## 安装下载 SmartPic.alfredworkflow 文件后，双击即可。当然，前提是已安装 Alfred（请自行安装）。## 配置SmartPic 其实是将图片上传至腾讯云存储桶，所以你需要自行申请免费的存储桶，并将存储桶相关参数配置到本地即可。1. 登录腾讯云创建存储桶 [点击创建](https://console.cloud.tencent.com/cos5/bucket)。点击会打开腾讯云，界面如下图，点击其中的```创建存储桶```进行创建。![创建存储桶](http://upload-images.jianshu.io/upload_images/1214187-ae19576086ef8e42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)2. 创建完成后的界面如下图：![创建后界面](http://upload-images.jianshu.io/upload_images/1214187-4c5536e8e6c760bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)3. 点击左侧的密钥管理，可以找到配置参数中的 secret_id、secret_key 两项![查看密钥](http://upload-images.jianshu.io/upload_images/1214187-ff75d03c44abb162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)4. 点击要使用的存储桶，进入下图界面。各个参数的对应值已在图中标出，包含 bucket、region、blog_prefix 三项。![存储桶参数](http://upload-images.jianshu.io/upload_images/1214187-733bfe1eb29e2629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)5. 呼出 Alfred，输入 SmartPic 命令，按下 Enter 进入菜单界面，并选择 ```config``` 菜单（如下图），在打开的文件中以 json 方式配置上述步骤中找到的 secret_id、secret_key、bucket、region、blog_prefix 五项参数，替换 ```******``` 部分即可，以下述代码为例。![配置 SmartPic](http://upload-images.jianshu.io/upload_images/1214187-1f8bb2a15c358cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ```config.txt```文件的配置格式 ```json &#123; &quot;secret_id&quot;: &quot;******&quot;, &quot;secret_key&quot;: &quot;******&quot;, &quot;region&quot;: &quot;ap-guangzhou(只取英文)&quot;, &quot;bucket&quot;: &quot;******&quot;, &quot;blog_prefix&quot;: &quot;******&quot; &#125; 使用SmartPic 命令此命令包含以下四个命令： config：配置存储桶参数 list：查看已上传图片列表，移动到指定项：Cmd + Y 可查看图片；Enter 可复制图片链接 uploadPic：上传图片：搜索出图片，Enter 后即可上传，上传完成会自动复制链接到剪切板 help：查看帮助文档 SmartPicUploadPic 命令上传图片：搜索出图片，Enter 后即可上传，上传完成会自动复制链接到剪切板。 注：本文的图片均用 SmartPic 上传获取链接。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 开发正在凋零吗？]]></title>
    <url>%2F2019%2F03%2F07%2FAndroid%20%E5%BC%80%E5%8F%91%E6%AD%A3%E5%9C%A8%E5%87%8B%E9%9B%B6%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[从Android诞生至今，其热度确实不比从前，但如果说Android开发会消失则是杞人忧天，它在短时间内是不会消失的，除非有新的替代平台力挽狂澜，像之前Android系统一样被人们所接受并普及开来，而这种可替代的平台短时间内不会成熟到可普及的地步。 但不容忽视的事实是：移动开发的光环确实正在消失，AI和区块链在慢慢火起来。一个现象就是毕业生对算法、数据分析等岗位一拥而上。 同时，一方面大前端的技术不够成熟，另一方面移动开发的岗位也变的更少，很多移动开发者都陷入了迷茫。 这里要认清的是，移动开发中，中高端的岗位变多，中高级开发人员的需求变多了。移动开发温度下降的原因无非是部分泡沫的破裂，接下来便是技术沉淀让移动开发重新充盈起来。温度下降不代表移动开发已经完全失势，而是像房价一样，一时的暴涨中必定是有泡沫存在的，终究会碰到泡沫破裂的冷却期。但是这意味着房价就此一蹶不振了吗？不是的，物价由供需决定，只要人们不断的涌向一线城市，需求总会大于供给，房价就会不断上涨。 移动开发也是如此，现在每个公司、每个产品都会涉及到手机应用，全世界的手机应用需要开发者来更新和维护，移动开发的需求仍然有很大的量级。另外，IoT、VR/AR都可以归入移动开发的一部分。移动开发不会消失，而会更加丰富。只不过移动开发到现在成熟之后，产品更加注重的是质量，这就要求开发者从初级到中高级的转变，能够将应用从基本实现上升为高质量的保证。要做出高质量的应用，需要了解底层知识，提升自己的能力才行。可以从三方面来进行自我的提升：了解一定的架构知识、高质量方面、高效方面。总结来说，在移动开发的进阶中，就是要了解一定的架构知识，同时要高效地做出高质量的应用。 有一个师傅带你学习和进阶能够让你更快的成长，避免走更多的弯路。 版权声明本文首发自简书：搜索作者 QinGeneral同步发于CSDN博客：搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[认知革命到革新人质]]></title>
    <url>%2F2019%2F03%2F07%2F%E8%AE%A4%E7%9F%A5%E9%9D%A9%E5%91%BD%E5%88%B0%E9%9D%A9%E6%96%B0%E8%AE%A4%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[认知革命到革新认知从数万年前因智人基因突变的认知革命起，人类的想象力得以提升。人们开始更多的交流，从日常八卦到建立共同想象，这种共同想象让人们能够突破150人的限制，参与人数更多的团体合作。 与大猩猩只能交流已存在的事物不同，人们不断的建立全体或大部分人类的共同想象，如中国的天地鬼神、西方的基督教、人权主义、公司等等。中国人想象出老天爷，然后皇帝向大众讲了一个“天之子”的故事，大家“信以为真”，皇帝这种“大众想象出的物体”持续了上千年。 除此之外，人类不断的创造出新的想象共同体，革新旧的想象。从皇室、平民、奴隶到人人生而平等，从四体液学说到现代医学，一种称作文化的东西让人类冲破 DNA 的枷锁，通过文化的革新来不断的进化。至此，人类不再需要偶然的基因突变来获得进化，而只需文化变迁即可。人类可以站在巨人的肩膀上，不断发展。 可以这样来描述认知革命之后的人类：在 DNA 圈定的很大范围内，通过不断更新、创造想象共同体，来进行基因之外的进化。 而反观现代人类自身，每个人的基因、出生环境在一定程度上给这个人画了一个圈，要想突破基因、环境的枷锁，ta 必须像认知革命后的人类一样，不断更新自己脑中的 “由人类和 ta 自身想象出的概念、观点”，来做到“自我进化”。通过自我进化掌握新的技术、新的认知，都能够让你更加适应当下快速变化的社会。革新认知让你对世界的认识更加接近现实；新技能的掌握、精进能够让你被社会更加需要。 无论如何，自我进化都会让你在残酷的现实中 “生存” 或者说 “活的更好” 的几率大大加大。其实这个自我进化的过程，被大家称作“学习”。至于如何学习，则是另一个故事了。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谈谈 Android 开发与女娲造人]]></title>
    <url>%2F2019%2F03%2F07%2F%E8%B0%88%E8%B0%88%20Android%20%E5%BC%80%E5%8F%91%E4%B8%8E%E5%A5%B3%E5%A8%B2%E9%80%A0%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[先来看看手机从开发者的角度来看一下手机组成： 屏幕（显示、触摸和反馈） 开发可调用硬件：相机、GPS、运动传感器… 网络部分 （CPU、GPU、内存、存储） 电池 屏幕是开发Android主要涉及的方面，需要对四大组件、UI控件、工程目录结构有简单了解；可调用硬件需要了解相应硬件的API；网络部分需要知道简单的网络知识，okhttp或者volley等第三方库的了解；CPU、GPU、内存方面，APP开发者能够涉及的内容较少，存储方面跟Java文件操作相似；电池就需要开发者深入学习，做一些省电优化的工作。 社会人当我们作为一个社会中的人的时候，每个人的理想状态就是： 首先做一个有能力，有用的人，可以帮助别人解决问题，为社会解决问题的人 还要做一个行为举止端庄，得体的人 最后要衣着端庄、整洁，最好有颜值 一个好的APP一个好的APP是什么样的呢？ 能够戳中用户痛点的功能，对用户来说有用 好的交互，用户上手就可以用，简单易懂 好的UI，风格统一，赏心悦目 开发APP与女娲造人这样看来，一个开发APP的开发者所处的位置，和女娲造人时所处的位置是一样的。目标是让自己的“孩子”有能力、行为举止得体、长得好看。 把APP比作一个人时，Android系统相当于他的社会环境。在这个环境中，有的人长得漂亮，有的人长得丑，有能干的，有不能干的。三个方面都可以的，是少之又少。 AndroidStudio便是“造人工具”，设计模式等便是好的、典型的“造人方法”，一些开源库便是“已有的肢体”。 最近在重温Android，之后会写一系列的从基础到进阶的文章。如果你有兴趣，欢迎共同探讨，共同进步。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谈谈读书方法]]></title>
    <url>%2F2019%2F03%2F07%2F%E8%B0%88%E8%B0%88%E8%AF%BB%E4%B9%A6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近学习了一下成甲、陈华伟、万维钢的读书方法。下面是对“非虚构类”书籍阅读方法的整理概括，以下几个方法不适用于小说等类型。 成甲的读书方法理念：读书要以用为目的。 读书方法： 先看封面、目录、序言、结尾（总结）了解本书讲什么 思考自己对书中内容的思考、观点、方法 结硬寨打呆仗，分为三层：现象层、原因层、行动层 a. 从现象层分析作者观点和自己观点的区别、优劣 b. 从原因层找到作者方法优劣的原因 c. 从行动层实践学到的方法 判断自己是否需要继续读完本书 小技巧： ● 彩虹笔记法标记书中内容：不同颜色表示不同类别的内容，如黄色代表重点、蓝色代表亮点、橙色代表数据、红色代表不懂的地方 ● 读不懂的地方标记起来，最后解决 ● 用笔记软件，如有道云笔记，管理知识，方便存取、查阅。把一些方法论总结出来，改善自己的行动 陈华伟的读书方法和做读书笔记方法步骤： 读完前言、目录、序之后，写下读本书后会起到的作用 读的过程中标注重点。 a. 纸质书：总结性句子用 下划线，亮点句子和故事用 波浪线（亮点指能够引发思考，能够刺激自己的句子） b. 电子书：总结性句子用“黄色”，亮点句子用”蓝色” 每章节用自己的话总结作者逻辑与观点，同时写下自己的感想，用1x1表格记录（或者用上横线 + 下横线） 发掘文中的亮点，写下自己所激发的思考 最后，对全文的脉络、亮点进行梳理。用自己的话进行总结、梳理，可以用思维导图、OmniOutliner做大纲整理 如果读了多个相同主题的书籍、文章，可以进行比较，写下自己的感悟、文章，发博客出去 万维钢做读书笔记的方法理念：做笔记的目标就是要能够取代原书，再次重温的时候直接看笔记即可。 作者做笔记分为五点： 梳理脉络——画出藏宝图 找到亮点——找到藏宝地点，挖走宝藏 大量自己看法和心得——用挖来的宝藏去继续“挣更多的宝藏”或“找到自己相似的宝藏” 找相关书籍的联系——看一下这个藏宝图和其他藏宝图是不是相似？哪个更加准确、细致？哪个更加进步？ 写笔记、文章——自己做一个主题相关的藏宝图，分享给别人 思考万维钢做读书笔记的方法和陈华伟的方法大致类似，都有梳理脉络、写自己看法心得、找联系、写作输出这些步骤。但是万维钢更进一步的是，强调“亮点的挖掘”，只有是能够激发自己思考的部分就挖走。这些亮点对自己的影响可能比书籍本身更大。 三者的共同点是：梳理脉络，有一个大的视野来读一本书；和自己的想法碰撞，建立起书中观点和自己观点的联系，织成网；有输出，成甲强调用到自己的生活之中，其他两人强调通过写文章的方式输出。 总的来说，读“非虚构类”书籍，目的就是为了拓展自己的视野，磨练自己的世界观；或者是提升自己某方面的技能，掌握某个方法论。那么，读书最后只有落到实地才能让这本书用起来。只有在读书过程中不断思考、碰撞，不断的实践，才是真正的在学习。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>书</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 内存泄漏场景及其解决方法]]></title>
    <url>%2F2019%2F03%2F07%2FAndroid%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文包括以下内容： 内存泄漏原理 Android内存泄漏发生的情况 检测内存泄漏的工具、方法 如何避免内存泄漏 1. 内存泄漏原理简单来说，Java的内存泄漏就是对象不再使用的时候，无法被JVM回收。内存泄漏最终会引发Out Of Memory。 在Java中，判断对象是否仍在使用的方法是：引用计数法，可达性分析。 引用计数法就是对每个对象所持有的引用进行计数，计数为0，则没有引用，判断为可回收状态。但是此方法存在的问题是循环引用，即A持有B的引用，B持有A的引用，同时AB不再使用时，无法回收AB，发生内存泄漏。 可达性分析就是从一些GC Root 对象出发，去遍历所含有对象的引用，以此递归。像树一样，从根向树枝查找可达的对象。最后没有标记到的对象即为可回收对象，解决了循环引用的问题。 但是即使采用可达性分析的方法，还是可能由于程序编写的问题引发内存泄漏。总结来说就是长周期的对象持有了短周期对象的引用，导致短周期对象无法回收，引起内存泄漏。 2. Android内存泄漏发生的情况内存泄漏是否发生的关键在于对象之间生命周期的长短。下面是可能发生内存泄漏的情况： 比较典型的是Activity的Context，包含大量的引用，比如View Hierarchies和其他资源。一旦无法释放Context，也意味着无法释放它指向的所有对象。 静态变量：静态变量的生命周期和应用的生命周期一样长。如果静态变量持有某个Activity的context，则会引发对应Activity无法释放，导致内存泄漏。如果持有application的context，就没有问题（以下例子是指Activity销毁时没有释放的情况） 单例模式：内部实现是静态变量和方法 静态的View：view默认持有Activity的context 静态Activity 监听器：当使用Activity的context注册监听，不再需要监听时没有取消注册。比如传感器的监听等 内部类 匿名内部类：持有外部类引用。匿名内部类和异步任务一起出现时，可能发生内存泄漏。Activity回收时，异步任务没有执行完毕会导致内存泄漏的发生。因为匿名任务类持有Activity引用，当匿名任务类的引用被另一线程持有，导致生命周期不一致的问题，进而导致内存泄漏 匿名的AsyncTask 1234567new AsyncTask&lt;String, String, String&gt;() &#123; @Override protected String doInBackground(String... params) &#123; // doSomething return null; &#125; &#125;; 匿名的TimerTask 123456new Timer().schedule(new TimerTask() &#123; @Override public void run() &#123; // doSomething &#125; &#125;, 1000); 匿名的Thread或Runnable 12345new Thread() &#123; @Override public void run() &#123; while(true); &#125; &#125;.start(); 非静态内部类：持有外部类引用 Handler：我们知道Handler处理消息是串行的，所以当Activity已经需要回收，但Looper仍有消息未处理完毕时会发生内存泄漏。因为Looper使用ThreadLocal保存，ThreadLocal是静态的，生命周期与当前应用一致。同时Looper持有MessageQueue的引用，MessageQueue持有Handler引用（msg.target），Handler持有外部Activity引用，导致Activity无法回收 非静态内部类有一个静态的实例：非静态内部类持有外部类引用，如果在某个地方有个非静态内部类的静态实例的话，同样会引起内存泄漏 资源对象未关闭：BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，使用后未关闭会导致内存泄漏。因为资源性对象往往都用了一些缓冲，缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果仅仅是把它的引用置null，而不关闭它们，也会造成内存泄漏 容器中的对象没有清理：集合一般占用内存较大，不及时关闭会导致内存紧张（不会导致内存泄漏，而会导致可用内存大大减少） webview 3. 检测、分析内存泄漏的工具 MemoryMonitor：随时间变化，内存占用的变化情况 MAT：输入HRPOF文件，输出分析结果 Histogram：查看不同类型对象及其大小 DominateTree：对象占用内存及其引用关系 MAT使用教程 LeakCanary：实时监测内存泄漏的库（LeakCanary原理） 4. 如何避免内存泄漏长周期的对象持有了短周期对象的引用，导致短周期对象无法回收，引起内存泄漏。所以在使用某个对象时，我们需要仔细研究对象的生命周期，当处理一些占用内存较大并且生命周期较长的对象时，可以使用软引用。对于一些资源操作对象，及时关闭。 不要在匿名内部类中进行异步操作 将非静态内部类转为静态内部类 + WeakReference（弱引用）的方式 在 Activity 回调 onDestroy 时或者 onStop 时 移除消息队列 MessageQueue 中的消息 静态变量置null 停止异步任务 取消注册 使用Context时，尽量使用Application 的 Context 尽量避免使用static 成员变量。另外可以考虑lazy初始化 为webView开启另外一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放 及时关闭资源。Bitmap 使用后调用recycle()方法 防止内存溢出的方法 及时清理容器，将集合里的东西clear，然后置为null 使用adapter时，使用ViewHolder来复用convertView 优化数据结构 比如HashMap和ArrayMap，优先使用ArrayMap；优先使用基本类型，而非包装类 减少占内存较大的枚举的使用 采用三级缓存机制：LRUCache 图片压缩：inSampleSize、RGB_565替换RGB_8888 尽量不要在循环中创建大量对象 注： 在C++ 中，内存分配释放有程序员自己管理。内存泄漏发生的情况是，如果有些对象被分配了内存空间，然后却不可达，由于C++中没有垃圾回收机制，导致无法再释放这些内存空间。 对于Java程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。就是说GC是不可控的，基本是透明的。 Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种 强引用(StrongReference)：JVM 宁可抛出 OOM ，也不会让 GC 回收具有强引用的对象 软引用(SoftReference)：只有在内存空间不足时，才会被回的对象 弱引用(WeakReference)：在 GC 时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存 虚引用(PhantomReference)：任何时候都可以被GC回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为GC回收Object的标志 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git 的诞生]]></title>
    <url>%2F2019%2F03%2F07%2FGit%20%E7%9A%84%E8%AF%9E%E7%94%9F%2F</url>
    <content type="text"><![CDATA[相信各位开发者对Git不会陌生，就算不熟悉Git相信你对GitHub也有所了解。而Git这款在版本管理工具中叱咤风云的软件是如何出现的呢？在Git之前版本管理又是如何发展的呢？在本文里我会对版本控制工具的发展和Git的起源的进行介绍。 我们在开发一款软件时，尤其是多人协作开发，代码的管理是十分重要的。比如个人开发时需要对代码的版本进行管理，多人协作开发时需要一个工具来进行代码的合并、冲突处理、版本管理等等。这样一款工具我们往往称之为“版本控制系统”。 在最初的日子里，我们同步、管理代码可能是通过软盘拷贝、文件服务器（类似现在的云盘）来进行的。但是这种方法丝毫没有处理代码冲突的能力，合并代码只能通过人工手动来操作，这大大消耗了我们的人力和时间。 diff 和 patch第一次改善这种状况是 diff 和 patch 命令的出现。假如我们现在有两个文本文件 a.txt 和 b.txt。其中 diff 命令可以比较 a.txt 和 b.txt 的文本差异，另外它还可以比较两个文件夹之间的差异。假如我们把差异保存到了diff.txt 中，patch 命令则可以根据 diff.txt 和 a.txt、b.txt 的其中任一文件得出另一文件。这两个工具的出现让我们合并代码的能力得以增强。 CVS 和 SVN第一个可以管理整个工程的版本工具CVS（ConCurrent Versions System）诞生于 1985年，它是由荷兰一所大学 Dick Grune 教授打造。当时教授在和几个学生协同开发一个项目，但苦于项目代码的合并，于是教授就基于单个文件版本工具 RCS 开发了 CVS。 CVS 采用 C/S 架构设计，服务端来进行版本库的管理工作，服务端通过只保留一份文件拷贝和记录差异使其存储效率大大提高。CVS 也奠定了版本控制工具的模型，CVS中的commit log、tag、branch等属性都在后续出现的版本控制工具中得以延续保留。 可以说CVS是集中式版本管理工具的开山鼻祖。当然CVS也存在很多问题，而正是因此，类CVS版本控制工具大量出现，在一定程度上解决了CVS存在的问题，SVN就是其一。 SVN（Subversion）于2000年由CollabNet资助开发，目标就是取代CVS。SVN优化了很多特性，如实现了原子提交、全局版本号、文件轻拷贝等，这些优化也使得它在版本控制工具中成为最佳选择之一。但SVN本质上是一种集中式版本管理工具，这种版本控制太依赖于服务器，如果服务器出现问题，版本控制将不可用；如果网络较差，提交代码将变得十分漫长。再加上SVN本身设计的一些问题，使用其进行版本管理也并存在很多不如意之处。 GitGit是由Linux之父Linus开发的，在2005年4月3号开始开发，到 4.7 仅四天时间Git就可以投入使用了。到同年6月份，Linux已经在使用Git管理代码了。 Linux版本管理最早是通过手工合并代码的方式进行的，不使用CVS的原因就是Linus坚决反对这种集中式的版本管理工具。而迫于其他开发者的压力，Linus最后决定使用BitKeeper一种分布式的版本管理工具。与集中式不同，使用分布式的版本管理工具每个人都可以在本地进行版本的管理，如日志提交、代码提交、创建tag和分支、合并分支等等操作。 而在2005年4月，Andrew Tridgell 为了开发一个可以与BitKeeper交互的工具，试图反编译BitKeeper。这让开发该软件的公司BitMover得知并取消了Linux社区免费试用BitKeeper的权利。这也成为了Linus开发Git的契机，促进了Git这一伟大作品的诞生。 Git为版本管理打开一扇新的大门，后续我会对Git的入门使用进行介绍，如有兴趣请继续关注。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RePlugin 插件启动源码分析]]></title>
    <url>%2F2019%2F03%2F07%2FRePlugin%20%E6%8F%92%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[大年初一，先祝各位新年快乐！今天还在看博客学习的兄dei很强大，如果能把一年节日假期时间分配到自己成长上，那你的一年 = 别人一年 * 1.1。如果能够做到年年如此，10年后你就相当于活了11年。而这期间，学习复利效应的效果是呈现指数增长的。当然，朋友关系也不能落下，但在节假日做无聊的事情就是浪费时间了。 之前搭建了RePlugin源码阅读环境，详情请参考博客RePlugin阅读源码环境搭建 。 今天来分析一下RePlugin启动插件（RePlugin.startActivity）的流程。 下图是我用StarUML画的时序图-SequenceDiagram，简单表现了RePlugin.startActivity调用后发生的事情及其先后顺序。 下面进行详细分析。 1. RePlugin.startActivityRePlugin中启动插件，就是通过调用以下方法。 12345RePlugin.startActivity(context, intent);// 或者RePlugin.startActivity(context, intent, pluginName, activity); RePlugin是一个有很多静态方法的类。集成了安装卸载插件、启动插件等功能。使用RePlugin框架，一般来说只需要操作RePlugin类就行。 2. Factory.startActivityWithNoInjectCN这两个startActivity方法，最终都会调用 1Factory.startActivityWithNoInjectCN(context, intent, plugin, activity, process); 但intent, pluginName, activity)```方法，中间多了一步，就是给intent设置ComponentName。会先调用以下方法初始化componentName，然后调用```startActivityWithNoInjectCN```方法。123```JavaFactory.startActivity Factory是框架内部的一个工具类，主要集成了查询插件、查询插件资源、查询Activity信息、加载插件等功能。在启动插件中，Factory中所做的工作就是设置ComponentName给Intent。其中ComponentName主要包括两个属性：pkgName和clsName。这两个属性和插件属性对应关系：pkgName == pluginName、clsName == activityName。 12345```Javaboolean result = sPluginManager.startActivity(context, intent, plugin, activity, process);RePlugin.getConfig().getEventCallbacks().onStartActivityCompleted(plugin, activity, result); 1234567第二行是调用RePluginConfig的方法回调，告知已经启动Activity。这里的RePluginConfig回调，是可以在自己宿主的application中设置的。设置回调后，就可以在application中进行各个事件的处理，比如插件安装失败事件回调方法```onInstallPluginFailed```。以官方samplehost代码为例，设置回调的代码如下。```Java// SampleApplication.javarepluginConfig.setEventCallbacks(new HostEventCallbacks(this)); 3. PluginCommImpl.startActivity在Factory.startActivityWithNoInjectCN中，调用了pluginCommImpl.startActivity方法，而在此方法中没有做任何实质的工作，直接调用了PluginLibraryInternalProxy.startActivity方法。 4. pluginLibraryInternalProxy.startActivityPluginLibraryInternalProxy是最终实现启动插件的地方，也是做了最多工作的地方。流程图见下图。 在PluginLibraryInternalProxy中，先判断download标签和plugin是否为null。download标签默认为true，目前没有手动修改的办法。如果判断成立，则回调application中的方法。 然后判断是否是动态类，是的话设置Intent、启动Activity即可。否则进入下一步。 如果插件还没有加载，调用onLoadLargePluginForActivity方法加载插件。然后初始化ComponentName，设置Intent，调用context.startActivity启动插件中指定的Activity。最后调用回调方法，通知application已经启动完毕。 总结这样来看，RePlugin启动插件，也就是RePlugin.startActivity方法的调用过程，最终还是调用context.startActivity方法实现的。RePlugin框架所做的就是对Activity的pkgName、activityName进行处理：使用这两个属性创建ComponentName，并传递给Intent；以及在启动插件的不同时期，对RePluginConfig的回调，如未找到插件时会回调onPluginNotExistsForActivity方法。 最后，RePlugin启动插件可以说是RePlugin框架源代码的入口，接下来会对插件安装、卸载等功能的源码进行分析，以此一步步的对RePlugin框架整体建立系统的认识，对RePlugin的实现机制有所了解。学习框架中的设计模式，最终能够应用到自己的代码中去。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RePlugin 阅读源码环境搭建]]></title>
    <url>%2F2019%2F03%2F07%2FRePlugin%20%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[RePlugin是一个开源的Android插件化框架，只hook一处的思想不禁让人想读一下它的源代码。另外了解一下RePlugin的源代码也能够方便自己代码的编写和对设计模式的认识。 RePlugin框架本身是基于AndroidStudio开发的，主要包括两种类型的库： Android Library Gradle 插件 每种库又分为宿主和插件，最后RePlugin包括四部分： replugin-host-gradle replugin-host-lib replugin-plugin-gradle replugin-plugin-lib 可以在官网查看其目录结构和下载源码 点击查看。 本文包括以下内容： 使用AndroidStudio搭建RePlugin源码阅读和编译环境 我的软件版本 下载源码和新建工程 导入RePlugin的4个module 编译修改后的module 导入sample代码，并使用自己的RePlugin 自定义Gradle插件 RePlugin源码阅读环境搭建0. 我的软件版本 AndroidStudio 3.0 RePlugin 2.2.2 运行系统 macOS High Sierra 1. 下载源码和新建工程点击去官网下载，或者直接使用终端命令： git clone https://github.com/Qihoo360/RePlugin.git 下载完成后，目录结构如下： 其中除了replugin-sample目录是官方示例代码外，其他目录为框架源码。也是我们需要导入到AndroidStudio进行阅读、修改、编译的代码。 AndroidStudio 新建工程比较简单，不再详述。 2. 导入RePlugin的4个module4个module的导入方法一致，见下图： 然后选择Source Directory 到RePlugin文件夹下的module文件夹。确定即可。 重复以上步骤四次，将RePlugin的四个module分别导入。导入后，工程结构如下： 其中app是新建工程自带module，其他四个分别对应RePlugin的四个module。 3. 编译修改后的module其中replugin-host-lib和replugin-plugin-lib为Android Library，可通过 implementation project(‘:replugin-host-lib’) 的方式在同一工程中直接使用，无需导出jar、aar包的过程。但是对于replugin-host-gradle和replugin-plugin-gradle这两个gradle插件，就需要使用先编译再配置引用的方式使用。以replugin-host-gradle为例，过程如下： a. 找到host-gradle的build.gradle文件，添加以下代码，之后点击按钮，同步工程123456789101112uploadArchives &#123; repositories &#123; mavenDeployer &#123; //提交到远程服务器： // repository(url: "http://www.xxx.com/repos") &#123; // authentication(userName: "admin", password: "admin") // &#125; //本地的Maven地址设置为/Users/***/repos repository(url: uri('/Users/****/repos')) &#125; &#125;&#125; build.gradle文件所在 b. 编译gradle插件打开Gradle标签页面，选择replugin-host-gradle下的upload/uploadArchives，这个选项是上一步加入的代码后新增的选项。双击编译，等编译完成后，去配置的文件夹 /Users/**/repos 下查看。 c. 导入sample代码，并使用自己的RePlugin导入sample代码和之前导入module过程一致，不在累述。 以下是修改配置文件，使用本地RePlugin的过程： 找到工程的build.gradle文件，一般在第一个，修改如下： 123456789101112131415161718buildscript &#123; ext.kotlin_version = '1.1.51' ext.repluginHostGradleVersion = '2.2.2' ext.repluginPluginGradleVersion = '2.2.2' repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.0' classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version" classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 我这里使用RePlugin版本均为2.2.2，可自行根据情况修改。以下两个是新加入的内容。 12classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' 然后找到samplehost module的build.gradle文件，在顶部添加以下内容： 12345678910111213buildscript &#123; repositories &#123; maven &#123; url uri("/Users/****/repos") &#125; mavenLocal() jcenter() mavenCentral() &#125; dependencies &#123; classpath "com.qihoo360.replugin:replugin-host-gradle:$repluginHostGradleVersion" &#125;&#125; 其中uri中的内容为编译gradle插件时配置的本地目录。 最后修改samplehost module的build.gradle文件的dependencies，主要是替换replugin-host-lib依赖，如下： 123456dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') compile 'com.android.support:appcompat-v7:25.3.1'// compile 'com.qihoo360.replugin:replugin-host-lib:2.2.1' implementation project(':replugin-host-lib')&#125; 最后运行samplehost即可。另外，每次修改gradle插件内容后，需要重新uploadArchives编译发布插件到本地，才能在自己的samplehost中使用修改后的插件。 到此，RePlugin源码阅读、修改、编译的环境就搭好了，相对简单。主要是gradle插件的配置。之后就可以探索RePlugin的世界了。 这里涉及到主要是gradle插件，以下说一下自定义gradle插件。 自定义gradle插件因为已经有写的很好的博客，在此不再重复编写。这篇文章写得十分全面，很有条理。以下内容转自博客，格式稍有修改：huachao1001的简书 我的CSDN博客同步发布：在AndroidStudio中自定义Gradle插件 转载请注明出处：【huachao1001的简书：http://www.jianshu.com/users/0a7e42698e4b/latest_articles】 一直都想好好学习AndroidStudio中的gradle，总感觉不懂如何在AndroidStudio中自定义gradle插件的程序员就不是个好程序员，这次上网查了一下相关资料，做了一个总结~ 1 创建Gradle ModuleAndroidStudio中是没有新建类似Gradle Plugin这样的选项的，那我们如何在AndroidStudio中编写Gradle插件，并打包出来呢？ (1) 首先，你得新建一个Android Project (2) 然后再新建一个Module，这个Module用于开发Gradle插件，同样，Module里面没有gradle plugin给你选，但是我们只是需要一个“容器”来容纳我们写的插件，因此，你可以随便选择一个Module类型（如Phone&amp;Tablet Module或Android Librarty）,因为接下来一步我们是将里面的大部分内容删除，所以选择哪个类型的Module不重要。 (3) 将Module里面的内容删除，只保留build.gradle文件和src/main目录。由于gradle是基于groovy，因此，我们开发的gradle插件相当于一个groovy项目。所以需要在main目录下新建groovy目录 (4) groovy又是基于Java，因此，接下来创建groovy的过程跟创建java很类似。在groovy新建包名，如：com.hc.plugin，然后在该包下新建groovy文件，通过new-&gt;file-&gt;MyPlugin.groovy来新建名为MyPlugin的groovy文件。 (5) 为了让我们的groovy类申明为gradle的插件，新建的groovy需要实现org.gradle.api.Plugin接口。如下所示： package com.hc.plugin import org.gradle.api.Plugin import org.gradle.api.Project public class MyPlugin implements Plugin&lt;Project&gt; { void apply(Project project) { System.out.println(&quot;========================&quot;); System.out.println(&quot;hello gradle plugin!&quot;); System.out.println(&quot;========================&quot;); } } 因为我本人对groovy也不是特别熟悉，所以我尽可能的用Java语言，使用System.out.println而不是用groovy的pintln “”，我们的代码里面啥也没做，就打印信息。 (6) 现在，我们已经定义好了自己的gradle插件类，接下来就是告诉gradle，哪一个是我们自定义的插件类，因此，需要在main目录下新建resources目录，然后在resources目录里面再新建META-INF目录，再在META-INF里面新建gradle-plugins目录。最后在gradle-plugins目录里面新建properties文件，注意这个文件的命名，你可以随意取名，但是后面使用这个插件的时候，会用到这个名字。比如，你取名为com.hc.gradle.properties，而在其他build.gradle文件中使用自定义的插件时候则需写成： apply plugin: &apos;com.hc.gradle&apos; 然后在com.hc.gradle.properties文件里面指明你自定义的类 implementation-class=com.hc.plugin.MyPlugin 现在，你的目录应该如下： (7) 因为我们要用到groovy以及后面打包要用到maven,所以在我们自定义的Module下的build.gradle需要添加如下代码： apply plugin: &apos;groovy&apos; apply plugin: &apos;maven&apos; dependencies { //gradle sdk compile gradleApi() //groovy sdk compile localGroovy() } repositories { mavenCentral() } 2 打包到本地Maven前面我们已经自定义好了插件，接下来就是要打包到Maven库里面去了，你可以选择打包到本地，或者是远程服务器中。在我们自定义Module目录下的build.gradle添加如下代码： //group和version在后面使用自定义插件的时候会用到 group=&apos;com.hc.plugin&apos; version=&apos;1.0.0&apos; uploadArchives { repositories { mavenDeployer { //提交到远程服务器： // repository(url: &quot;http://www.xxx.com/repos&quot;) { // authentication(userName: &quot;admin&quot;, password: &quot;admin&quot;) // } //本地的Maven地址设置为D:/repos repository(url: uri(&apos;D:/repos&apos;)) } } } 其中，group和version后面会用到，我们后面再讲。虽然我们已经定义好了打包地址以及打包相关配置，但是还需要我们让这个打包task执行。点击AndroidStudio右侧的gradle工具，如下图所示： 可以看到有uploadArchives这个Task,双击uploadArchives就会执行打包上传啦！执行完成后，去我们的Maven本地仓库查看一下： 其中，com/hc/plugin这几层目录是由我们的group指定，myplugin是模块的名称，1.0.0是版本号（version指定）。 3 使用自定义的插件接下来就是使用自定义的插件了，一般就是在app这个模块中使用自定义插件，因此在app这个Module的build.gradle文件中，需要指定本地Maven地址、自定义插件的名称以及依赖包名。简而言之，就是在app这个Module的build.gradle文件中后面附加如下代码： buildscript { repositories { maven {//本地Maven仓库地址 url uri(&apos;D:/repos&apos;) } } dependencies { //格式为--&gt;group:module:version classpath &apos;com.hc.plugin:myplugin:1.0.0&apos; } } //com.hc.gradle为resources/META-INF/gradle-plugins //下的properties文件名称 apply plugin: &apos;com.hc.gradle&apos; 好啦，接下来就是看看效果啦！先clean project(很重要！),然后再make project.从messages窗口打印如下信息： 好啦，现在终于运行了自定义的gradle插件啦！ 4 开发只针对当前项目的Gradle插件前面我们讲了如何自定义gradle插件并且打包出去，可能步骤比较多。有时候，你可能并不需要打包出去，只是在这一个项目中使用而已，那么你无需打包这个过程。 只是针对当前项目开发的Gradle插件相对较简单。步骤之前所提到的很类似，只是有几点需要注意： 新建的Module名称必须为BuildSrc 无需resources目录 目录结构如下所示： 其中，build.gradle内容为： apply plugin: &apos;groovy&apos; dependencies { compile gradleApi()//gradle sdk compile localGroovy()//groovy sdk } repositories { jcenter() } SecondPlugin.groovy内容为： package com.hc.second import org.gradle.api.Plugin import org.gradle.api.Project public class SecondPlugin implements Plugin&lt;Project&gt; { void apply(Project project) { System.out.println(&quot;========================&quot;); System.out.println(&quot;这是第二个插件!&quot;); System.out.println(&quot;========================&quot;); } } 在app这个Module中如何使用呢？直接在app的build.gradle下加入 apply plugin: com.hc.second.SecondPlugin clean一下，再make project，messages窗口信息如下： 由于之前我们自定义的插件我没有在app的build.gradle中删除，所以hello gradle plugin这条信息还会打印. 参考资料：http://kvh.io/cn/tags/EmbraceAndroidStudio/ 献上源码：http://download.csdn.net/detail/huachao1001/9565654 第二部分所转载的文章信息：作者：huachao1001链接：https://www.jianshu.com/p/d53399cd507b來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[黑苹果安装与踩坑记]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E4%B8%8E%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[根据我自己的经历，对于一个开发者来讲，macOS + Alfred + terminal + Dash … 等软件的使用体验比Windows好很多。同时受限于MacPro的价格，所以最近萌生了在自配电脑上安装黑苹果的想法，MacPro还是工作之后再入手。本文可能涉及侵权等问题，所以本文只用于个人知识学习，不授权于任何人用于商业用途。 本文包含以下内容： 我的电脑配置与macOS High Sierra 制作Mac系统安装U盘 安装macOS 安装驱动 给要安装系统的硬盘添加启动项 工具包 一、我的电脑配置与macOS High Sierra CPU：Intel i5 7500（自带 Intel HD Graphic 630 集显） 显卡：七彩虹/技嘉 GeForce GTX 1050 Ti（Pascal系列） 主板：技嘉（GIGABYTE） B250-WIND （M-ATX紧凑型） 网卡：瑞昱RTL8168/8111/8112 Gigabit EthernetController 声卡：瑞昱ALC887 高保真音频 内存：金士顿骇客神条 Fury系列 DDR4 2133频 8G 硬盘：金士顿固态硬盘 M.2接口 128GB 散热器：采融B41（风冷） 电源：蓝暴炫动二代400W 我已验证安装的系统有macOS High Sierra10.13.3（17D47） 和 10.13.2（17C88）版本，两者安装方法完全一致，我也都安装成功。但是由于10.13.3（17D47）所对应的NVIDIA Web Driver有bug，安装后无法驱动显卡。所以目前建议安装10.13.2（17C88）版本，同时安装对应的NVIDIA Web Driver版本即可。等新版本NVIDIA Web Driver的bug修复后，再进行安装。 以下说的是macOS High Sierra 10.13.2（17C88版本）的安装过程。此教程只保证能够作用于以上的电脑配置。 二、制作Mac系统安装U盘 （此方法需要一台Mac）此U盘的制作方法需要一台装有macOS系统的电脑或虚拟机，当然也有用Windows制作安装U盘的方法，可以参考博客 点击查看，但此教程中的方法未亲自验证。 准备：装有macOS系统的电脑、8G及以上U盘（最好是USB 2.0）、macOS High Sierra 10.13.2系统。 制作过程： 打开App Store，下载macOS High Sierra系统。目前最新的版本是10.13.3，10.13.2系统版本可以从这里下载：点击下载，密码: t3du。下载后解压，将其中的“安装 macOS High Sierra.app”文件移到“/Applications”文件夹下（就是“应用程序”文件夹） 使用UniBeast工具安装，点击下载，需要注册登录，不要怕麻烦，https://www.tonymacx86.com 是一个很棒的黑苹果站点，然后按以下步骤进行 使用系统自带的“磁盘工具”格式化U盘为图中格式和GUID分区。最新的系统似乎不会显示GUID分区，可以通过终端命令来查看：diskutil list。找到U盘名字的部分，包含EFI分区即可，注意EFI分区要大于200M，效果如图所示 UniBeast工具中，BootLoader Configuration 选项选择 “UEFI Boot Mode” Graphics Configuration 不要勾选内容（这个对应于显卡参数，1050Ti显卡一定不要勾选） 安装即可完成macOS High Sierra启动U盘的制作 修改BIOS设置，我的电脑配置所对应的BIOS设置项目如下： 电脑启动时按“DEL”键进入BIOS设置 在“储存并离开”面板中，选择 加载默认配置 在“芯片组” 面板中，取消支持 VT-d 在“BIOS功能”面板中，设置 Win8 / 10系统 选项为 “其他系统” 在“集成外设/SuperIO配置”中，取消支持 IO Serial Port 在“集成外设/USB程序”中，设置支持 XHCI Handoff， 此步骤不设置，会导致系统加载一点就不动了 注： 写U盘的时候，UniBeast在加载一点之后，进度条会不动，这是在写系统到U盘，耐心等待即可 UniBeast 8.1 对应的系统系列是 macOS High Sierra，适合10.13.2版本安装 参考内容： unibeast-install-macos-high-sierra-on-any-supported-intel-based-pc 简书博客 三、安装macOS准备要把想装macOS High Sierra系统的硬盘格式化为 GPT + EFI 分区格式，可以在Windows系统中用DiskGenius工具操作。 安装步骤 插入U盘，F12 选择从U盘 clover启动 系统进行从U盘的第一次加载 加载完成之后，先选择语言，然后使用“磁盘工具”格式化要安装macOS的硬盘为APFS格式，命名为“Mac”。然后安装系统。安装之后重启继续安装 从U盘clover启动，在Clover页面选择其中的“install High Sierra from MAC”。会多次重启，选择相同选项启动即可 安装完成 注：安装时不要连接网络，也不要登录iCloud，否则会出问题 安装的时候可能会遇到的问题及其解决 系统第一次加载一点就卡住不动解决：严格按照第二步中“我的电脑对应的BIOS设置”来操作BIOS即可。 第一次加载到大概3/5的地方，开始转菊花解决：在UniBeast制作启动U盘时，不能选择 Inject NVDIA 选项（此选项用于驱动老型号显卡——GeForce 630及以下），因为这会修改启动U盘的EFI/Clover/Config.plist文件中的Graphic子标签：Intel 设置为false，NVDIA设置为true。这可能是因为老版本驱动不支持1050Ti显卡 四、安装驱动安装驱动过程 选择U盘启动，之后选择“Boot from MAC”。如果硬盘已经加入了clover引导项，也可以从硬盘clover启动Mac 进入系统之后，使用MultiBeast安装驱动，各个选项如下（安装驱动时不要挂载EFI分区，否则会导致安装FakeSMC失败） QuickStart：UEFI Boot Mode Drivers： Audio：VoodooHDA v2.8.9 Disk：3rd Party SATA &amp; 3rd Party eSATA &amp; Intel Generic AHCI SATA Misc：默认 FakeSMC不动 Network：IntelMausiEthernet v2.3.0 Booloaders：Clover UEFI Boot Mode + Emulated NVRAM Customize Graphics Configuration：Intel HD 6xx &amp; Intel Graphics Fixup SSDT Options：Sandy Bridge Core i5 System Definitions：iMac 14，2 Build中选择Mac，点击Install进行安装 重启系统 成功启动后，把U盘中的启动项 - EFI文件夹 拷贝到硬盘的 EFI分区中。使用硬盘启动系统，正常启动即可。这是作为U盘Clover启动项的备份，为了测试显卡驱动，需修改config.plist文件，以此来防止修改错误导致进不了系统 安装 NVIDIA Web Driver，安装很简单，可以参考教程：点击查看，安装出现问题及解答：点击查看，软件下载：点击下载 删除config.plist中的 nv_disable=1，同时编辑config.plist文件的如下部分，重启即可 123456789&lt;key&gt;SystemParameters&lt;/key&gt; &lt;dict&gt; &lt;key&gt;InjectKexts&lt;/key&gt; &lt;string&gt;YES&lt;/string&gt; &lt;key&gt;InjectSystemID&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NvidiaWeb&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; 安装驱动碰到的问题 问题：MultiBeast安装到FakeSMC失败解决：使用MultiBeast安装驱动时，不要挂载U盘的EFI 注： 第二步和第五步的软件可同时进行安装 不要修改Graphics/Inject/NVidia标签为true，这样会在重启后，系统加载到一半时转菊花 nvda_drv是以前驱动Nvidia显卡的方法，不支持Sierra。NvidiaWeb是Sierra中的新方法 在macOS High Sierra中，注意要取消nv_disable，设置NvidiaWeb 五、给要安装系统的硬盘添加启动项要求要安装黑苹果系统的硬盘是 GPT + EFI格式分区，可以在Windows系统中用DiskGenius工具操作，安装懒人版系统似乎不用必须是此分区格式。 过程在安装好的macOS High Sierra系统中操作：把启动U盘EFI分区下的 EFI文件夹 直接复制到硬盘的EFI分区即可。此过程主要目的是不再使用U盘作为引导项启动macOS，摆脱对U盘依赖。而是直接使用硬盘的clover引导启动系统。所以此步骤较为灵活，可以选择任何合适的时机进行操作。 也可参考此教程的方法给要安装系统的硬盘添加“clover启动项”：点击查看教程 ，见教程第三步“Clover 引导安装”。 六、工具包所有工具见百度云盘，点击下载，密码: im9u 最后晒一下我的Hackintosh。 祝好运！ 版权声明本文首发自简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
  </entry>
</search>
